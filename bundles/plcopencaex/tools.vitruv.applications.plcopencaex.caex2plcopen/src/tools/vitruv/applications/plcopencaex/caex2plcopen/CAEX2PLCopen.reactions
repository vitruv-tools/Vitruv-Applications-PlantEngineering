import org.automationml.caex.caex.CAEXFile
import org.eclipse.xtext.EcoreUtil2
import org.plcopen.xml.tc60201.PouType1
import org.automationml.caex.caex.ExternalInterface
import org.automationml.caex.caex.DocumentRoot
import org.apache.log4j.Level
import CAEXResolver.CAEXInheritanceResolver
import CAEXResolver.CAEXStringResolver
import CAEXResolver.CAEXInternalElementResolver

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://org.automationml.caex" as caex

reactions: caex2plcopen
in reaction to changes in CAEX
execute actions in PLCOpen

reaction LogEachChange {
	after any change
	call {
		//logger.debug("Debug Output")
		//logger.warn("Warn Output")
		//logger.error("Error Output")
		//logger.fatal("Fatal Output")
		//logger.info("Info Output")
		//logger.trace("Trace Output")
	}
}

// ***** ExternalInterface in Klassendefinition hinzufügen, entfernen

reaction AddExternalInterface {
	after element caex::ExternalInterface inserted in caex::SystemUnitClass[externalInterface]
	call {
		val caexFile = EcoreUtil2.getContainerOfType(newValue, CAEXFile)
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(newValue.refBaseClassPath ,caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
			addCorrespondenceToPLCopen(newValue, caexFile)
		}
		
		// Prototyp!!
	} 
}

reaction RemoveExternalInterface {
	after element removed from caex::SystemUnitClass[externalInterface]
	call {
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath ,caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
			// cast funktioniert wegen Überprüfung in 'resolveInterfacePath', Fehlschlagen der Überprüfung führt zu FALSE in 'isInterfaceInstanceOf'
			removeCorrespondenceFromPLCopen(oldValue as ExternalInterface)
		}
		
		val listOfInstances = CAEXInternalElementResolver.getInternalElementsForSystemUnitClass(affectedEObject.name, caexFile)
		
	}
}

// ***** Interface Typ einfügen/entfernen (ändern dadurch abgehandelt)

reaction AddExternalInterfaceType {
	after attribute insert in caex::ExternalInterface[refBaseClassPath]
	call {
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(newValue ,caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
			addCorrespondenceToPLCopen(affectedEObject, caexFile)
		}
		
		// Prototyp!!
	}
}

/*reaction ChangeExternalInterfaceType {
	after attribute replaced at caex::ExternalInterface[refBaseClassPath]
	call {
		if(oldValue.equals("AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")){
			removeCorrespondenceFromPLCopen(affectedEObject)
		}
		if(newValue.equals("AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")){
			val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
			addCorrespondenceToPLCopen(affectedEObject, caexFile)
		} 
	}
}*/

reaction RemoveExternalInterfaceType {
	after attribute remove from caex::ExternalInterface[refBaseClassPath]
	call {
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(oldValue, caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
			removeCorrespondenceFromPLCopen(affectedEObject)
		}
		
		// Prototyp!!
	}
}

// ***** Pfadangabe in CAEX zu PLCopen Datei geändert

reaction ChangeExternalInterfacePath {
	after attribute replaced at caex::Attribute[value] 
	with {
		val attributeParent = EcoreUtil2.getContainerOfType(affectedEObject, ExternalInterface)
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		affectedEObject.name.equals("refURI")
		attributeParent !== null 
		&& CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(attributeParent.refBaseClassPath, caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")
	}
	call {
		val attributeParent = EcoreUtil2.getContainerOfType(affectedEObject, ExternalInterface)
		val caexFile = EcoreUtil2.getContainerOfType(attributeParent, CAEXFile)
		removeCorrespondenceFromPLCopen(attributeParent)
		addCorrespondenceToPLCopen(attributeParent, caexFile)
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung zu setzen

routine addCorrespondenceToPLCopen (caex::ExternalInterface externalInterface, caex::CAEXFile caexFile) {
	match {
		val plcProject = retrieve plcopen::ProjectType corresponding to caexFile //mit Pfadabgleich??	Und dann evtl neues Dokument anlegen?? Pfad überhaupt schon vorhanden?? selber anlegen??
		//val pouTypes = EcoreUtil2.getAllContentsOfType(plcProject, PouType1)
	}
	action {
		//add correspondence between externalInterface and pouType
		add correspondence between externalInterface and plcProject
	}
}

routine removeCorrespondenceFromPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface
	}
	action {
		remove correspondence between externalInterface and plcPouType
	}
}

// ***** Anlegen einer SystemUnitClass -> Anlegen einer PLCopen Datei mit Grundstruktur
// sinnlos?? Nutzerinteraktion??
// genauso bei: Rolle anlegen, internes Element anlegen

reaction SystemUnitClassAdded {
	after element caex::SystemUnitClass inserted in caex::SystemUnitClassLib[systemUnitClass]
	call {
		val caexRoot =  EcoreUtil2.getContainerOfType(affectedEObject, DocumentRoot)
		//Containerobjekt auch anlegen
		addPLCopenFileWithStructure(newValue, caexRoot)
	}
}

routine addPLCopenFileWithStructure(caex::SystemUnitClass newClass, caex::DocumentRoot caexRoot) {
	action {
		val newPouType = create plcopen::PouType1 and initialize {
			newPouType.name = newClass.name
		}
		val newPousType = create plcopen::PousType and initialize {
			newPousType.pou.add(newPouType)
		}
		val newTypesType = create plcopen::TypesType and initialize {
			newTypesType.pous = newPousType
		}
		val newProjectType = create plcopen::ProjectType and initialize {
			newProjectType.types = newTypesType
		}
		val newDocumentRoot = create plcopen::DocumentRoot and initialize {
			newDocumentRoot.project = newProjectType
			persistProjectRelative(caexRoot, newDocumentRoot, newClass.name + "plcopen.xml");
		}
		add correspondence between newPouType and newClass
	}
}

// ***** Anlegen eines internen Elements mit Klassenbezug -> Korrespondenz setzen? (Werte aus Klasse direkt klonen?, Nutzerinteraktion?)
// ***** Anlegen eines internen Elements mit Rollenbezug -> Korrespondenz setzen?
// ***** Klassenbeschreibung ändern -> Auswirkungen auf Elemente? Nutzerinteraktion? (Prototypbasiert!)
// ***** Rollenbeschreibung ändern -> Auswirkungen auf Elemente? Nutzerinteraktion?
// ***** Klasse bzw. Klassenbib löschen (Kaskade beachten) (Enthaltenes in Klon schreiben? Nutzerinteraktion?)

// ***** Interface zu internem Element hinzufügen/ändern/löschen (evtl Überschreibung Klasse/Rolle beachten, Nutzerinteraktion?)
// ***** internes Element bzw. Instanzhierarchie löschen (Kaskade beachten) überhaupt notwendig?? (abgehandelt durch Interface entfernen?)
// ***** Rolle bzw. Rollenbib löschen (Kaskade beachten) ( - "" -)
// ***** Anlegen, Löschen Spiegelobjekt
// ***** Ändern, Löschen Spiegelvorlage (Nutzerinteraktion?)
// ***** Interface zu Rolle hinzufügen/ändern/löschen

// ***** AdditionalInformation (Version, Name, Änderungsdatum, etc.) setzen/ändern/löschen -> FileHeader ändern

// ***** Änderung Einheiten -> Welche relevant? Auswirkungen auf? (Scaling?, Position?, ...?)