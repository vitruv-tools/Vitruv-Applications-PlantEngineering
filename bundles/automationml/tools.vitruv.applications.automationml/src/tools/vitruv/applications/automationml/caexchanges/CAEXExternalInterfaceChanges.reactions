import org.eclipse.xtext.EcoreUtil2
import org.plcopen.xml.tc60201.PouType1
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import caex.caex30.caex.CAEXFile
import caex.caex30.caex.InternalElement
import caex.caex30.caex.SystemUnitClass
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import tools.vitruv.applications.automationml.utils.clonechangestests.InternalElementChecker
import tools.vitruv.applications.automationml.utils.amlutils.AMLAggregatorResolver
import edu.kit.sdq.aml_aggregator.AMLProject
import org.plcopen.xml.tc60201.ProjectType
import org.khronos.collada.COLLADAType
import org.khronos.collada.SceneType
import tools.vitruv.applications.automationml.utils.amlutils.TagHelper

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexExternalInterfaceChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Interface Typ einfügen/ändern/entfernen

reaction AddExternalInterfaceType {
	after attribute insert in caex::ExternalInterface[refBaseClassPath]
	call {
		logger.debug("Reaction AddExternalInterfaceType")
		
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(newValue, caexFile)
		val container = affectedEObject.eContainer
				
		if(CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceType)) {
			addPathAttributeToExternalInterface(affectedEObject)
		} else if(CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceType)) {
			addPathAttributeToExternalInterface(affectedEObject)
		}
		
		if(container instanceof InternalElement) {
			//TODO Spiegelelement?? Vorüberprüfung notwendig??
		} else if(container instanceof SystemUnitClass) {
			val userInputClone = userInteractor.confirmationDialogBuilder.message("Sollen alle Internen Elemente, die diese Klasse referenzieren, analog abgeändert werden?").startInteraction
			if(userInputClone) {
				changeExternalInterfaceTypeInInternalElement(affectedEObject, container)
			}
		}
	}
}

reaction ChangeExternalInterfaceType {
	after attribute replaced at caex::ExternalInterface[refBaseClassPath]
	call {
		logger.debug("Reaction ChangeExternalInterfaceType")
		
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val externalInterfaceTypeOld = CAEXStringResolver.resolveInterfacePath(oldValue, caexFile)
		val externalInterfaceTypeNew = CAEXStringResolver.resolveInterfacePath(newValue, caexFile)
		val container = affectedEObject.eContainer
		
		val isOldPlcopen = CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceTypeOld)
		val isOldCollada = CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceTypeOld)
		val isNewPlcopen = CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceTypeNew)
		val isNewCollada = CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceTypeNew)
		
		if(isOldPlcopen) {
			removeCorrespondenceBetweenInterfaceAndPLCopen(affectedEObject)
			removePathAttributeFromExternalInterface(affectedEObject)
		} else if(isOldCollada) {
			removeCorrespondenceBetweenInterfaceAndCollada(affectedEObject)
			removePathAttributeFromExternalInterface(affectedEObject)
		} 
		
		if(isNewPlcopen || isNewCollada) {
			addPathAttributeToExternalInterface(affectedEObject)
		}
		
		if(container instanceof InternalElement) {
			//TODO Spiegelelement?? Vorüberprüfung notwendig??
		} else if(container instanceof SystemUnitClass) {
			val userInputClone = userInteractor.confirmationDialogBuilder.message("Sollen alle Internen Elemente, die diese Klasse referenzieren, analog abgeändert werden?").startInteraction
			if(userInputClone) {
				changeExternalInterfaceTypeInInternalElement(affectedEObject, container)
			}
		}
	}
}


reaction RemoveExternalInterfaceType {
	after attribute remove from caex::ExternalInterface[refBaseClassPath]
	call {
		logger.debug("Reaction RemoveExternalInterfaceType")
				
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(oldValue, caexFile)
		val container = affectedEObject.eContainer
				
		if(CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceType)) {
			removeCorrespondenceBetweenInterfaceAndPLCopen(affectedEObject)
			removePathAttributeFromExternalInterface(affectedEObject)
		} else if(CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceType)) {
			removeCorrespondenceBetweenInterfaceAndCollada(affectedEObject)
			removePathAttributeFromExternalInterface(affectedEObject)
		}
		
		if(container instanceof InternalElement) {
			//TODO Spiegelelement?? Vorüberprüfung notwendig
		} else if(container instanceof SystemUnitClass) {
			val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle Internen Elemente, die diese Klasse referenzieren, analog abgeändert werden?").startInteraction
			if(userInput) {
				changeExternalInterfaceTypeInInternalElement(affectedEObject, container)
			}
		}
	}
}

// ***** Pfadangabe in CAEX zu PLCopen Datei geändert

reaction ChangeExternalInterfacePath {
	after attribute replaced at caex::Attribute[value] 
	with {
		affectedEObject.name.equals("refURI") && EcoreUtil2.getContainerOfType(affectedEObject, ExternalInterface) !== null 
	}
	call {
		logger.debug("Reaction ChangeExternalInterfacePath")
				
		val attributeParent = EcoreUtil2.getContainerOfType(affectedEObject, ExternalInterface)
		val caexFile = EcoreUtil2.getContainerOfType(attributeParent, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(attributeParent.refBaseClassPath, caexFile)
		val parentContainer = attributeParent.eContainer
				
		if (CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceType)) {
			changeCorrespondencesDueToPathChanges(attributeParent, caexFile, newValue, false)
		} else if(CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceType)) {
			changeCorrespondencesDueToPathChanges(attributeParent, caexFile, newValue, true)
		}
		
		if(parentContainer instanceof InternalElement) {
			//TODO Spiegelelement?? Vorüberprüfung notwendig
		} else if(parentContainer instanceof SystemUnitClass) {
			val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle Internen Elemente, die diese Klasse referenzieren, analog abgeändert werden?").startInteraction
			if(userInput) {
				changePathForExternalInterfaceInInternalElement(attributeParent, parentContainer, newValue)
			}
		}
	}
}

// ***** Routine, um mit Pfadänderungen umzugehen

//Boolean false: plcopen
routine changeCorrespondencesDueToPathChanges (caex::ExternalInterface externalInterface, caex::CAEXFile caexFile, String newPath, Boolean isCollada ) {
	match {
		val caexContainer = retrieve aml::CAEXContainer corresponding to caexFile tagged with TagHelper.TAG
	}
	action {
		execute{
			if(isCollada) {
				val colladaContainer = AMLAggregatorResolver.getColladaContainer(caexContainer.eContainer as AMLProject, newPath)
				if(colladaContainer !== null) {
					removeCorrespondenceBetweenInterfaceAndCollada(externalInterface)
					addCorrespondenceBetweenInterfaceAndCollada(externalInterface, colladaContainer)
					return;
				}
			} else {
				val plcopenContainer = AMLAggregatorResolver.getPLCopenContainer(caexContainer.eContainer as AMLProject, newPath)
				if(plcopenContainer !== null) {
					removeCorrespondenceBetweenInterfaceAndPLCopen(externalInterface)
					addCorrespondenceBetweenInterfaceAndPLCopen(externalInterface, plcopenContainer)
					return;
				}
			}
			
			val userInput = userInteractor.confirmationDialogBuilder.message("Der angegebene Pfad existiert nicht. Soll ein neues Dokument angelegt werden? Alternativ würden der bisherige Pfad überall in den neuen verwandelt werden.").startInteraction
			if(userInput) {
				if(isCollada) {
					createNewColladaContainer(externalInterface, caexContainer.eContainer as AMLProject, newPath)
				} else {
					createNewPLCopenContainer(externalInterface, caexContainer.eContainer as AMLProject, newPath)
				}
			} else {
				if(isCollada) {
					changeAllCorrespondingColladaPathes(externalInterface, newPath)
				} else {
					changeAllCorrespondingPLCopenPathes(externalInterface, newPath)
				}
			}
		}
	}
}

// ***** Hilfsroutinen, um auf nicht vorhandene Pfade reagieren zu können

routine createNewPLCopenContainer (caex::ExternalInterface externalInterface, aml::AMLProject container, String path) {
	action {
		val newContainer = create aml::PLCopenContainer and initialize {
			newContainer.path = path
		}
		execute {
			removeCorrespondenceBetweenInterfaceAndPLCopen(externalInterface)
			addCorrespondenceBetweenInterfaceAndPLCopen(externalInterface, newContainer)
			
		}
	}
}

routine createNewColladaContainer (caex::ExternalInterface externalInterface, aml::AMLProject container, String path) {
	action {
		val newContainer = create aml::ColladaContainer and initialize {
			newContainer.path = path
		}
		execute {
			removeCorrespondenceBetweenInterfaceAndCollada(externalInterface)
			addCorrespondenceBetweenInterfaceAndCollada(externalInterface, newContainer)
		}
	}
}

routine changeAllCorrespondingPLCopenPathes (caex::ExternalInterface externalInterface, String newPath) {
	match {
		val pouType = retrieve plcopen::PouType1 corresponding to externalInterface tagged with TagHelper.TAG
		val plcopenContainer = retrieve aml::PLCopenContainer corresponding to EcoreUtil2.getContainerOfType(pouType, ProjectType) tagged with TagHelper.TAG
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to pouType tagged with TagHelper.TAG
	}
	action {
		update plcopenContainer {
			plcopenContainer.path = newPath
		}
		execute {
			for(ExternalInterface currExternalInterface : externalInterfaces) {
				val uriAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(currExternalInterface, "refUri")
				uriAttribute.value = newPath
			}
		}
	}
}

routine changeAllCorrespondingColladaPathes (caex::ExternalInterface externalInterface, String newPath) {
	match {
		val scene = retrieve collada::SceneType corresponding to externalInterface tagged with TagHelper.TAG
		val colladaContainer = retrieve aml::ColladaContainer corresponding to EcoreUtil2.getContainerOfType(scene, COLLADAType) tagged with TagHelper.TAG
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to scene tagged with TagHelper.TAG
	}
	action {
		update colladaContainer {
			colladaContainer.path = newPath
		}
		execute {
			for(ExternalInterface currExternalInterface : externalInterfaces) {
				val uriAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(currExternalInterface, "refUri")
				uriAttribute.value = newPath
			}
		}
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung zu setzen bzw. zu entfernen

routine addCorrespondenceBetweenInterfaceAndPLCopen (caex::ExternalInterface externalInterface, aml::PLCopenContainer container) {
	match {
		val plcProject = retrieve plcopen::ProjectType corresponding to container tagged with TagHelper.TAG
	}
	action {
		execute {
			val pouTypes = EcoreUtil2.getAllContentsOfType(plcProject, PouType1)
			addCorrespondenceBetweenInterfaceAndPou(externalInterface, pouTypes.get(0))
		}
	}
}

routine addCorrespondenceBetweenInterfaceAndPou(caex::ExternalInterface externalInterface, plcopen::PouType1 pou) {
	action {
		add correspondence between externalInterface and pou tagged with TagHelper.TAG
	}
}

routine removeCorrespondenceBetweenInterfaceAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface tagged with TagHelper.TAG
	}
	action {
		remove correspondence between externalInterface and plcPouType tagged with TagHelper.TAG
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Geometriebeschreibung zu setzen bzw. zu entfernen

routine addCorrespondenceBetweenInterfaceAndCollada (caex::ExternalInterface externalInterface, aml::ColladaContainer container) {
	match {
		val colladaProject = retrieve collada::COLLADAType corresponding to container tagged with TagHelper.TAG
	}
	action {
		execute {
			val sceneTypes = EcoreUtil2.getAllContentsOfType(colladaProject, SceneType) 
			addCorrespondenceBetweenInterfaceAndScene(externalInterface, sceneTypes.get(0))
		}
	}
}

routine addCorrespondenceBetweenInterfaceAndScene(caex::ExternalInterface externalInterface, collada::SceneType scene) {
	action {
		add correspondence between externalInterface and scene tagged with TagHelper.TAG
	}
}

routine removeCorrespondenceBetweenInterfaceAndCollada (caex::ExternalInterface externalInterface){
	match {
		val colladaScene = retrieve collada::SceneType corresponding to externalInterface tagged with TagHelper.TAG
	}
	action {
		remove correspondence between externalInterface and colladaScene tagged with TagHelper.TAG
	}
}

// ***** Routinen, um ein Pfadattribut einem ExternalInterface hinzuzufügen bzw. zu entfernen

routine addPathAttributeToExternalInterface(caex::ExternalInterface externalInterface){
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = ""
		}
		update externalInterface {
			externalInterface.^attribute.add(newAttribute)
		}
	}
}

routine removePathAttributeFromExternalInterface(caex::ExternalInterface externalInterface){
	action {
		execute {
			val pathAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(externalInterface, "refUri")
			if(pathAttribute !== null){
				externalInterface.^attribute.remove(pathAttribute)
			}
		}
	}
}

// ***** Routinen, um interne Elemente abzuändern, analog zur Änderung der Klasse

routine changeExternalInterfaceTypeInInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass tagged with TagHelper.TAG
	}
	action {
		execute {
			val filteredInternalElements = InternalElementChecker.filterInternalElementsForChanges(internalElements, systemUnitClass)
			for(InternalElement currInternalElement : filteredInternalElements) {
				val foundedInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(currInternalElement, externalInterface.name)
				foundedInterface.refBaseClassPath = externalInterface.refBaseClassPath
			}
		}
	}
}

routine changePathForExternalInterfaceInInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass, String path) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass tagged with TagHelper.TAG
	}
	action {
		execute {
			val filteredInternalElements = InternalElementChecker.filterInternalElementsForChanges(internalElements, systemUnitClass)
			for(InternalElement currInternalElement : filteredInternalElements) {
				val foundedInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(currInternalElement, externalInterface.name)
				val pathAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(foundedInterface, "refUri")
				pathAttribute.value = path
			}
		}
	}
}