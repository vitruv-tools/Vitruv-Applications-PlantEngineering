import tools.vitruv.applications.automationml.utils.propertybasedtags.PrototypTags
import tools.vitruv.applications.automationml.utils.propertybasedtags.CloneTags
import tools.vitruv.applications.automationml.utils.aml.AMLTags
import tools.vitruv.applications.automationml.utils.aml.CAEXUtils
import caex.caex30.caex.InternalElement
import caex.caex30.caex.SystemUnitClass
import tools.vitruv.applications.automationml.utils.propertybasedtags.PropertyTags

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexAttributeValueChanges
in reaction to changes in CAEX
execute actions in CAEX

/**
 * reaction for changing the value of an attribute in a prototype
 */
reaction ChangeAttributeInClone {
	after attribute replaced at caex::Attribute[value]
	with {
		affectedEObject.eContainer instanceof SystemUnitClass && 
		(!(affectedEObject.eContainer instanceof InternalElement))
	}
	call {
		val prototype = affectedEObject.eContainer as SystemUnitClass
		checkAdaptationForAllClones(prototype, affectedEObject, oldValue)
	}
}

/**
 * routine to check, if a mark for the prototype exists
 */
routine checkAdaptationForAllClones(caex::SystemUnitClass prototype, caex::Attribute property, String oldValue) {
	match {
		val clones = retrieve many caex::InternalElement corresponding to prototype tagged with AMLTags.PROTOTYPE_CLONE
		val libNeverTagged = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.NEVER
		val libAlwaysTagged = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.ALWAYS
	}
	action {
		execute {
			if(!libNeverTagged.isPresent && !libAlwaysTagged.isPresent) {
				for(InternalElement currClone : clones) {
					checkAdaptationForClone(currClone, property, oldValue)
				}
			}
		}
	}
}

/**
 * routine to check, if a specific should be adapted to the change of the attribute in the prototype
 */
routine checkAdaptationForClone(caex::InternalElement clone, caex::Attribute property, String oldValue) {
	match {
		val taggedWithDescriptive = retrieve optional caex::SystemUnitClass corresponding to clone tagged with CloneTags.DESCRIPTIVE
		val taggedWithAbstract = retrieve optional caex::SystemUnitClass corresponding to clone tagged with CloneTags.ABSTRACT
		val taggedWithReal = retrieve optional caex::SystemUnitClass corresponding to clone tagged with CloneTags.REAL
		
		val taggedWithBehaviour = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.BEHAVIOUR
		val taggedWithSafty = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.SAFTY
		val taggedWithComposition = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.COMPOSITION
		val taggedWithMaterial = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.MATERIAL
		val taggedWithTechnology = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.TECHNOLOGY
		val taggedWithRule = retrieve optional caex::SystemUnitClass corresponding to property tagged with PropertyTags.RULE
	}
	action {
		execute {
			val isDescriptive = taggedWithDescriptive.isPresent
			val isAbstract = taggedWithAbstract.isPresent
			val isReal = taggedWithReal.isPresent
			
			val isBehaviour = taggedWithBehaviour.isPresent
			val isSafty = taggedWithSafty.isPresent
			val isComposition = taggedWithComposition.isPresent
			val isMaterialOrTech = taggedWithMaterial.isPresent || taggedWithTechnology.isPresent
			val isRule = taggedWithRule.isPresent
			
			val cloneProperty = CAEXUtils.getAttributeInClone(property.name, clone)
			if(cloneProperty === null || cloneProperty.value === null) {
				return
			}
			val hasChangedValue = !cloneProperty.value.equals(oldValue)
			
			if(isDescriptive && !hasChangedValue) {
				copyValueToClone(cloneProperty, property)
				return
			}
			
			if(isRule) {
				copyValueToClone(cloneProperty, property)
				return
			}
			
			if(isSafty) {
				askUser(clone.name, cloneProperty, property)
				return
			}
			
			if(isAbstract && isComposition) {
				askUser(clone.name, cloneProperty, property)
				return
			}
			
			if(isAbstract && isMaterialOrTech) {
				copyValueToClone(cloneProperty, property)
				return
			}
			
			if(!isAbstract && isMaterialOrTech && !hasChangedValue) {
				askUser(clone.name, cloneProperty, property)
				return
			}
			
			if(isBehaviour && isReal) {
				checkAdaptationForBehaviourProperty(cloneProperty, property, hasChangedValue)
				return
			}
			
			if(isBehaviour && !isReal && !hasChangedValue) {
				copyValueToClone(cloneProperty, property)
				return
			}
			
			if(isBehaviour && !isReal && hasChangedValue) {
				askUser(clone.name, cloneProperty, property)
				return
			}
		}
	}
}

/**
 * routine to check, if a specific clone should be adapted to the change of an attribute in the prototype, which is marked with "behaviour"
 */
routine checkAdaptationForBehaviourProperty(caex::Attribute cloneProperty, caex::Attribute prototypeProperty, Boolean hasCloneChanged) {
	match {
		val clone = retrieve optional caex::InternalElement corresponding to cloneProperty tagged with PropertyTags.MAINTAINABLE
	}
	action {
		execute {
			if(clone.isPresent) {
				if(hasCloneChanged) {
					askUser(clone.get.name, cloneProperty, prototypeProperty)
				} else {
					copyValueToClone(cloneProperty, prototypeProperty)
				}
			}
		}
	}
}

/**
 * routine to ask the user, if a specific clone should be adapted to the change of an attribute in the prototype
 */
routine askUser(String cloneName, caex::Attribute cloneProperty, caex::Attribute prototypeProperty) {
	action {
		execute {
			val shouldCloneAdapted = userInteractor.confirmationDialogBuilder.message("Should this clone (" + cloneName  + ") be adapted to the change of its prototype?").startInteraction
			if(shouldCloneAdapted) {
				copyValueToClone(cloneProperty, prototypeProperty)
			}
		}
	}
}

/**
 * routine to copy the new value of an attribtue to a specific clone
 */
routine copyValueToClone(caex::Attribute cloneProperty, caex::Attribute prototypeProperty) {
	action {
		update cloneProperty {
			cloneProperty.value = prototypeProperty.value
		}
	}
}