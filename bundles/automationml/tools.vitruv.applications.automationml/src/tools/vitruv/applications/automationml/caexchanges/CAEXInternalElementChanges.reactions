import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import caex.caex30.caex.CAEXFile
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import tools.vitruv.applications.automationml.utils.amlutils.TagHelper
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.ExternalInterfaceType

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexInternalElementChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Klassenangabe in Internem Element ändern

reaction ChangeSystemClassInInternalElement {
	after attribute replaced at caex::InternalElement[refBaseSystemUnitPath]
	call {
		logger.debug("Reaction ChangeSystemClassInInternalElement")
				
		if(newValue.isNullOrEmpty) {
			removeCorrespondenceBetweenClassAndInstance(affectedEObject)
			return
		}
		
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val systemUnitClass = CAEXStringResolver.resolveSystemClassPath(newValue, caexFile)
		
		if(systemUnitClass === null) {
			val shouldClassCreated = userInteractor.confirmationDialogBuilder.message("Klasse existiert nicht. Soll eine neue Klasse erzeugt werden? (Ansonsten wird die Änderung zurückgerollt)").startInteraction
			if(shouldClassCreated) {
				removeCorrespondenceBetweenClassAndInstance(affectedEObject)
				createSystemUnitClassInTree(affectedEObject)
			} else {
				//TODO Änderung wird zurückgerollt
				// Sprachstatement dazu nicht vorhanden, deswegen diese Notation
				affectedEObject.refBaseSystemUnitPath = oldValue
			}
			return
		}
		
		removeCorrespondenceBetweenClassAndInstance(affectedEObject)
		val shouldValuesCloned = userInteractor.confirmationDialogBuilder.message("Sollen die Werte der Klasse in das InternalElement geklont werden? (Achtung: nur ExternalInterface wird geklont!)").startInteraction
		if(shouldValuesCloned) {
			copyPLCopenValuesFromPrototypeToClone(affectedEObject, systemUnitClass)
			copyColladaValuesFromPrototypeToClone(affectedEObject, systemUnitClass)
		}
		addCorrespondenceBetweenClassAndInstance(affectedEObject, systemUnitClass)
	}
}

// ***** ExternalInterface von Internem Element entfernen (hinzufügen nicht notwendig!)

reaction RemoveExternalInterfaceFromInternalElement {
	after element removed from caex::InternalElement[externalInterface]
	with {
		oldValue instanceof ExternalInterface
	}
	call {
		logger.debug("Reaction RemoveExternalInterfaceFromInternalElement")
				
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath ,caexFile)
		
		if(CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceType)) {
			removeCorrespondenceBetweenInterfaceInInternalAndPLCopen(oldValue as ExternalInterface)
		} else if (CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceType)) {
			removeCorrespondenceBetweenInterfaceInInternalAndCollada(oldValue as ExternalInterface)
		}
	}
}

// ***** Routine, um Korrespondenz aufzulösen beim Entfernen einer Klassenangabe

routine removeCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement) {
	match {
		val systemUnitClass = retrieve caex::SystemUnitClass corresponding to internalElement tagged with TagHelper.PROTOTYPE_CLONE
	}
	action {
		remove correspondence between internalElement and systemUnitClass tagged with TagHelper.PROTOTYPE_CLONE
	}
}

// ***** Routine, um eine Klasse anzulegen bei Angabe eines toten Pfades

routine createSystemUnitClassInTree(caex::InternalElement internalElement) {
	action {
		val newSystemUnitClass = create caex::SystemUnitClass
		execute {
			//TODO Baum durchsuchen, ab wo der Pfad tot ist
		}
		add correspondence between internalElement and newSystemUnitClass tagged with TagHelper.PROTOTYPE_CLONE
	}
}

// ***** Routinen, um Klone beim Hinzufügen einer Klassenangabe abzuändern

routine addCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	action {
		add correspondence between systemUnitClass and internalElement tagged with TagHelper.PROTOTYPE_CLONE
	}
}

routine copyPLCopenValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, ExternalInterfaceType.PLCOPEN)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = InterfaceForAttributeChecker.getAttributeInExternalInterface(SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.PLCOPEN), "refUri").value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.PLCOPEN)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
	}
}

routine copyColladaValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, ExternalInterfaceType.COLLADA)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = InterfaceForAttributeChecker.getAttributeInExternalInterface(SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.COLLADA), "refUri").value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.COLLADA)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung oder Geometriebeschreibung zu entfernen

routine removeCorrespondenceBetweenInterfaceInInternalAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface tagged with TagHelper.INTERFACE_POU
	}
	action {
		remove correspondence between externalInterface and plcPouType tagged with TagHelper.INTERFACE_POU
	}
}

routine removeCorrespondenceBetweenInterfaceInInternalAndCollada (caex::ExternalInterface externalInterface){
	match {
		val colladaScene = retrieve collada::SceneType corresponding to externalInterface tagged with TagHelper.INTERFACE_SCENE
	}
	action {
		remove correspondence between externalInterface and colladaScene tagged with TagHelper.INTERFACE_SCENE
	}
}