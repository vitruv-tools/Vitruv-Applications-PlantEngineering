import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import caex.caex30.caex.CAEXFile
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.aml.CAEXUtils
import tools.vitruv.applications.automationml.utils.aml.AMLTags
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.ExternalInterfaceType
import tools.vitruv.applications.automationml.utils.stringreferences.caex.SystemUnitClassUtils
import caex.caex30.caex.InternalElement

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexInternalElementChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Rollenangabe in Internem Element ändern

reaction ChangeRoleClassInInternalElement {
	after attribute replaced at caex::RoleRequirements[refBaseRoleClassPath]
	with {
		affectedEObject.eContainer instanceof InternalElement
	}
	call {	
		val container = affectedEObject.eContainer as InternalElement
					
		if(newValue.isNullOrEmpty) {
			removeCorrespondenceBetweenInternalElementAndRoleClass(container)
			return
		}
		
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val roleClass = CAEXStringResolver.resolveRolePath(newValue, caexFile)
		
		if(roleClass === null) {
			val userInput = userInteractor.confirmationDialogBuilder.message("Rolle existiert nicht. Soll eine erzeugt werden? Andernfalls wird die Änderung zurückgerollt").startInteraction
			if(userInput) {
				createRoleClassInTree(newValue, caexFile, container)
			} else {
				//TODO Änderung wird zurückgerollt
				// Sprachstatement dazu nicht vorhanden, deswegen diese Notation
				affectedEObject.refBaseRoleClassPath = oldValue
				return
			}
		}
		
		removeCorrespondenceBetweenInternalElementAndRoleClass(container)
		addCorrespondenceBetweenInternalElementAndRoleClass(container, roleClass)
	}
}

// ***** Klassenangabe in Internem Element ändern

reaction ChangeSystemClassInInternalElement {
	after attribute replaced at caex::InternalElement[refBaseSystemUnitPath]
	call {
		logger.debug("Reaction ChangeSystemClassInInternalElement")
				
		if(newValue.isNullOrEmpty) {
			removeCorrespondenceBetweenClassAndInstance(affectedEObject)
			return
		}
		
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val systemUnitClass = SystemUnitClassUtils.getSystemClassByPath(newValue, caexFile)
		
		if(systemUnitClass === null) {
			userInteractor.notificationDialogBuilder.message("Klasse existiert nicht. Änderung wird zurückgerollt").startInteraction
			//TODO Änderung wird zurückgerollt
			// Sprachstatement dazu nicht vorhanden, deswegen diese Notation
			affectedEObject.refBaseSystemUnitPath = oldValue
			return
		}
		
		removeCorrespondenceBetweenClassAndInstance(affectedEObject)
		val shouldValuesCloned = userInteractor.confirmationDialogBuilder.message("Sollen die Werte der Klasse in das InternalElement geklont werden? (Achtung: nur ExternalInterface wird geklont!)").startInteraction
		if(shouldValuesCloned) {
			copyPLCopenValuesFromPrototypeToClone(affectedEObject, systemUnitClass, caexFile)
			copyColladaValuesFromPrototypeToClone(affectedEObject, systemUnitClass, caexFile)
		}
		addCorrespondenceBetweenClassAndInstance(affectedEObject, systemUnitClass)
	}
}

// ***** ExternalInterface von Internem Element entfernen (hinzufügen nicht notwendig!)

reaction RemoveExternalInterfaceFromInternalElement {
	after element removed from caex::InternalElement[externalInterface]
	with {
		oldValue instanceof ExternalInterface
	}
	call {
		logger.debug("Reaction RemoveExternalInterfaceFromInternalElement")
				
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath ,caexFile)
		
		if(CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterfaceType, caexFile)) {
			removeCorrespondenceBetweenInterfaceInInternalAndPLCopen(oldValue as ExternalInterface)
		} else if (CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterfaceType, caexFile)) {
			removeCorrespondenceBetweenInterfaceInInternalAndCollada(oldValue as ExternalInterface)
		}
	}
}

// ***** Routine, um Korrespondenz aufzulösen beim Entfernen einer Klassenangabe

routine removeCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement) {
	match {
		val systemUnitClass = retrieve caex::SystemUnitClass corresponding to internalElement tagged with AMLTags.PROTOTYPE_CLONE
	}
	action {
		remove correspondence between internalElement and systemUnitClass tagged with AMLTags.PROTOTYPE_CLONE
	}
}

// ***** Routine, um eine Klasse anzulegen bei Angabe eines toten Pfades

routine createRoleClassInTree(String path, caex::CAEXFile caexFile, caex::InternalElement internalElement) {
	action {
		execute {
			val splitIndex = path.lastIndexOf("/")
			val pathToContainer = path.substring(0, splitIndex)
			val nameOfClass = path.substring(splitIndex + 1)
			val container = CAEXStringResolver.resolveRolePath(pathToContainer, caexFile)
			createRoleClass(nameOfClass, container, internalElement)
		}
	}
}

routine createRoleClass(String name, caex::RoleClass container, caex::InternalElement internalElement) {
	match {
		val oldRoleClass = retrieve caex::RoleClass corresponding to internalElement tagged with AMLTags.CLONE_ROLE
	}
	action {
		val newClass = create caex::RoleClass and initialize {
			newClass.name = name
		}
		update container {
			container.roleClass.add(newClass)
		}
		remove correspondence between oldRoleClass and internalElement tagged with AMLTags.CLONE_ROLE
		add correspondence between newClass and internalElement tagged with AMLTags.CLONE_ROLE
	}
}

// ***** Routinen, um Klone beim Hinzufügen einer Klassenangabe abzuändern

routine addCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	action {
		add correspondence between systemUnitClass and internalElement tagged with AMLTags.PROTOTYPE_CLONE
	}
}

routine copyPLCopenValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass, caex::CAEXFile root) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, ExternalInterfaceType.PLCOPEN, root)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = CAEXUtils.getUriAttributeInPLCopenInterface(systemUnitClass).value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.PLCOPEN, root)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
	}
}

routine copyColladaValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass, caex::CAEXFile root) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, ExternalInterfaceType.COLLADA, root)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			//TODO Utils refactoring
			newAttribute.value = CAEXUtils.getUriAttributeInColladaInterface(systemUnitClass).value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, ExternalInterfaceType.COLLADA, root)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung oder Geometriebeschreibung zu entfernen

routine removeCorrespondenceBetweenInterfaceInInternalAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface tagged with AMLTags.INTERFACE_POU
	}
	action {
		remove correspondence between externalInterface and plcPouType tagged with AMLTags.INTERFACE_POU
	}
}

routine removeCorrespondenceBetweenInterfaceInInternalAndCollada (caex::ExternalInterface externalInterface){
	match {
		val colladaScene = retrieve collada::SceneType corresponding to externalInterface tagged with AMLTags.INTERFACE_SCENE
	}
	action {
		remove correspondence between externalInterface and colladaScene tagged with AMLTags.INTERFACE_SCENE
	}
}

// ***** Routinen für Rollen und Korrespondenze

routine removeCorrespondenceBetweenInternalElementAndRoleClass(caex::InternalElement elem) {
	match {
		val roleClass = retrieve caex::RoleClass corresponding to elem tagged with AMLTags.CLONE_ROLE
	}
	action {
		remove correspondence between elem and roleClass tagged with AMLTags.CLONE_ROLE
	}
}

routine addCorrespondenceBetweenInternalElementAndRoleClass(caex::InternalElement elem, caex::RoleClass role) {
	action {
		add correspondence between elem and role tagged with AMLTags.CLONE_ROLE
	}
}