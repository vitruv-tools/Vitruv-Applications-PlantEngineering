import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import caex.caex30.caex.CAEXFile
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker.InterfaceType

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexInternalElementChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Klasse zu Internem Element hinzufügen bzw. entfernen

reaction AddSystemClassToInternalElement {
	after attribute insert in caex::InternalElement[refBaseSystemUnitPath]
	call {
		val caexFile = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val systemUnitClass = CAEXStringResolver.resolveSystemClassPath(newValue, caexFile)
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen die Werte der Klasse in das InternalElement geklont werden? (Achtung: nur ExternalInterface wird geklont!)").startInteraction
		if(userInput) {
			copyPLCopenValuesFromPrototypeToClone(affectedEObject, systemUnitClass)
			copyColladaValuesFromPrototypeToClone(affectedEObject, systemUnitClass)
		}
		addCorrespondenceBetweenClassAndInstance(affectedEObject, systemUnitClass)
	}
}

reaction RemoveSystemClassFromInternalElement {
	after attribute remove from caex::InternalElement[refBaseSystemUnitPath]
	call {
		removeCorrespondenceBetweenClassAndInstance(affectedEObject)
		
	}
}

// ***** ExternalInterface von Internem Element entfernen (hinzufügen nicht notwendig!)

reaction RemoveExternalInterfaceFromInternalElement {
	after element removed from caex::InternalElement[externalInterface]
	with {
		oldValue instanceof ExternalInterface
	}
	call {
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath ,caexFile)
		val plcopenInterfacePath = "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface"
		val colladaInterfacePath = "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/COLLADAInterface"
		
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterfaceType, plcopenInterfacePath)) {
			removeCorrespondenceBetweenInterfaceInInternalAndPLCopen(oldValue as ExternalInterface)
		} else if (CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterfaceType, colladaInterfacePath)) {
			removeCorrespondenceBetweenInterfaceInInternalAndCollada(oldValue as ExternalInterface)
		}
	}
}

// ***** Routine, um Korrespondenz aufzulösen beim Entfernen einer Klassenangabe

routine removeCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement) {
	match {
		val systemUnitClass = retrieve caex::SystemUnitClass corresponding to internalElement
	}
	action {
		remove correspondence between internalElement and systemUnitClass
	}
}

// ***** Routinen, um Klone beim Hinzufügen einer Klassenangabe abzuändern

routine addCorrespondenceBetweenClassAndInstance(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	action {
		add correspondence between internalElement and systemUnitClass
	}
}

routine copyPLCopenValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, InterfaceType.PLCOPEN)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = InterfaceForAttributeChecker.getAttributeInExternalInterface(SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, InterfaceType.PLCOPEN), "refUri").value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, InterfaceType.PLCOPEN)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
		
		add correspondence between internalElement and systemUnitClass
	}
}

routine copyColladaValuesFromPrototypeToClone(caex::InternalElement internalElement, caex::SystemUnitClass systemUnitClass) {
	match {
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, InterfaceType.COLLADA)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = InterfaceForAttributeChecker.getAttributeInExternalInterface(SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, InterfaceType.COLLADA), "refUri").value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			val systemClassInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(systemUnitClass, InterfaceType.COLLADA)
			newInterface.name = systemClassInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = systemClassInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
		
		add correspondence between internalElement and systemUnitClass
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung oder Geometriebeschreibung zu entfernen

routine removeCorrespondenceBetweenInterfaceInInternalAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface
	}
	action {
		remove correspondence between externalInterface and plcPouType
	}
}

routine removeCorrespondenceBetweenInterfaceInInternalAndCollada (caex::ExternalInterface externalInterface){
	match {
		val colladaXYZ = retrieve collada::COLLADAType corresponding to externalInterface	//TODO richtigen Datentyp
	}
	action {
		remove correspondence between externalInterface and colladaXYZ
	}
}