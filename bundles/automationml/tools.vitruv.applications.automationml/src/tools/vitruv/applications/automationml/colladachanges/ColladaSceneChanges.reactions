import tools.vitruv.applications.automationml.utils.aml.AMLTags
import org.eclipse.xtext.EcoreUtil2
import org.khronos.collada.COLLADAType
import tools.vitruv.applications.automationml.utils.stringreferences.collada.ColladaStringUtils

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: colladaSceneChanges
in reaction to changes in Collada
execute actions in Collada

/**
 * reaction for a replaced scene
 */
reaction ReplaceScene {
	after element collada::SceneType replaced at collada::COLLADAType[scene]
	with {
		oldValue !== null
	}
	call {
		logger.debug("ReplaceScene")
		
		//TODO reject change
		affectedEObject.scene = oldValue
	}
}

/**
 * reaction for a replaced instance of a visual scene definition
 */
reaction ReplaceInstance {
	after element collada::InstanceWithExtra replaced at collada::SceneType[instanceVisualScene]
	with {
		oldValue !== null
	}
	call {
		logger.debug("ReplaceInstance")
		
		//TODO reject change
		affectedEObject.instanceVisualScene = oldValue
	}
}

/**
 * reaction for changing the reference to a visual scene definition
 */
reaction ChangeVisualInstance {
	after attribute replaced at collada::InstanceWithExtra[url]
	call {
		logger.debug("ChangeVisualInstance")
		
		val root = EcoreUtil2.getContainerOfType(affectedEObject, COLLADAType)
		val visualScene = ColladaStringUtils.getVisualSceneByID(newValue, root)
				
		if(visualScene === null) {
			val shouldVisualSceneCreated = userInteractor.confirmationDialogBuilder.message("ID is not existing. Should a new visual scene description be created? Otherwise the change would be rejected.").startInteraction
			if(shouldVisualSceneCreated) {
				removeCorrespondenceBetweenInstanceAndVisualScene(affectedEObject)
				addVisualSceneInTree(root, affectedEObject, newValue)
			} else {
				//TODO reject change
				affectedEObject.url = oldValue
			}
		} else {
			removeCorrespondenceBetweenInstanceAndVisualScene(affectedEObject)
			addCorrespondenceBetweenInstanceAndVisualScene(affectedEObject, visualScene)
		}
	}
}

/**
 * routine to remove the correspondence between a visual scene definition and its instance
 */
routine removeCorrespondenceBetweenInstanceAndVisualScene(collada::InstanceWithExtra instance) {
	match {
		val visualScene = retrieve collada::VisualSceneType corresponding to instance tagged with AMLTags.SCENE_VISUAL
	}
	action {
		remove correspondence between visualScene and instance tagged with AMLTags.SCENE_VISUAL
	}
}

/**
 * routine to add a correspondence between a visual scene definition and its instance
 */
routine addCorrespondenceBetweenInstanceAndVisualScene(collada::InstanceWithExtra instance, collada::VisualSceneType visualScene) {
	action {
		add correspondence between instance and visualScene tagged with AMLTags.SCENE_VISUAL
	}
}

/**
 * routine to add a visual scene definition in the collada file, if an implicit reference in an instance is not existing 
 */
routine addVisualSceneInTree(collada::COLLADAType root, collada::InstanceWithExtra instance, String id) {
	action {
		val geometryInstance = create collada::InstanceGeometryType and initialize {
			geometryInstance.url = ""
		}
		val node = create collada::NodeType1 and initialize {
			node.instanceGeometry.add(geometryInstance)
		}
		val visualScene = create collada::VisualSceneType and initialize {
			visualScene.id = id
			visualScene.node.add(node)
		}
		val visualSceneLib = create collada::LibraryVisualScenesType and initialize {
			visualSceneLib.visualScene.add(visualScene)
		}
		update root {
			root.libraryVisualScenes.add(visualSceneLib)
		}
		add correspondence between instance and visualScene
	}
}