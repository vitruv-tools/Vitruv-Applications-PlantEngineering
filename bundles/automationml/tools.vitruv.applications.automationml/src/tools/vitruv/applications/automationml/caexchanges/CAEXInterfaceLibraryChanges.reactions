import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.aml.AMLTags
import tools.vitruv.applications.automationml.utils.aml.AMLBasicStrings
import caex.caex30.caex.InterfaceClass
import tools.vitruv.applications.automationml.utils.aml.CAEXUtils
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import caex.caex30.caex.CAEXFile
import tools.vitruv.applications.automationml.utils.stringreferences.caex.SystemUnitClassUtils

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexInterfaceLibraryChanges
in reaction to changes in CAEX
execute actions in CAEX

reaction RemoveInterfaceClassLibrary {
	after element caex::InterfaceClassLib removed from caex::CAEXFile[interfaceClassLib]
	call {
		logger.debug("RemoveInterfaceClassLibrary")		
		
		if(AMLBasicStrings.automationMLInterfaceBaseLibName.equals(oldValue.name)) {
			//TODO entspricht Zurückrollen der Änderung
			affectedEObject.interfaceClassLib.add(oldValue)
			return
		}
		
		val root = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		val listOfInterfaceClasses = EcoreUtil2.getAllContentsOfType(oldValue, InterfaceClass)
		
		for(InterfaceClass currClass : listOfInterfaceClasses) {
			changeRefBaseClassPathOfExternalInterfaces(currClass, "")
			val newPath = CAEXStringResolver.getCompletePath(CAEXStringResolver.resolveInterfacePath(currClass.refBaseClassPath, root))
			changeInheritanceInInterfaces(CAEXStringResolver.getCompletePath(currClass), newPath, root)
		}
	}
}

reaction RemoveInterfaceClass {
	after element caex::InterfaceClass removed from caex::InterfaceClass[interfaceClass]
	call {
		logger.debug("RemoveInterfaceClass")
		
		if(AMLBasicStrings.automationMLExternalBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalColladaBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalPLCopenBaseInterfaceName.equals(affectedEObject.name)
		) 
		{
			//TODO Änderung zurückrollen
			affectedEObject.interfaceClass.add(oldValue)
			return
		}
		
		val root = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		
		changeRefBaseClassPathOfExternalInterfaces(oldValue, "")
		val newPath = CAEXStringResolver.getCompletePath(CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath, root))
		changeInheritanceInInterfaces(CAEXStringResolver.getCompletePath(oldValue), newPath, root)
		
		val listOfInterfaceClasses = EcoreUtil2.getAllContentsOfType(oldValue, InterfaceClass)
		
		for(InterfaceClass currClass : listOfInterfaceClasses) {
			changeRefBaseClassPathOfExternalInterfaces(currClass, "")
			val currNewPath = SystemUnitClassUtils.getCompletePathOfSystemUnitClass(currClass.refBaseClassPath, root)
			changeInheritanceInInterfaces(CAEXStringResolver.getCompletePath(currClass), currNewPath, root)
		}
	}
}

reaction RemoveInterfaceClassFromLib {
	after element caex::InterfaceClass removed from caex::InterfaceClassLib[interfaceClass]
	call {
		logger.debug("RemoveInterfaceClassFromLib")
		
		if(AMLBasicStrings.automationMLBaseInterfaceName.equals(affectedEObject.name)) {
			//TODO Änderung zurückrollen
			affectedEObject.interfaceClass.add(oldValue)
			return
		}
		
		val root = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		
		changeRefBaseClassPathOfExternalInterfaces(oldValue, "")
		val newPath = CAEXStringResolver.getCompletePath(CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath, root))
		changeInheritanceInInterfaces(CAEXStringResolver.getCompletePath(oldValue), newPath, root)
		
		val listOfInterfaceClasses = EcoreUtil2.getAllContentsOfType(oldValue, InterfaceClass)
		
		for(InterfaceClass currClass : listOfInterfaceClasses) {
			changeRefBaseClassPathOfExternalInterfaces(currClass, "")
			val currNewPath = SystemUnitClassUtils.getCompletePathOfSystemUnitClass(currClass.refBaseClassPath, root)
			changeInheritanceInInterfaces(CAEXStringResolver.getCompletePath(currClass), currNewPath, root)
		}
	}
}

reaction ChangeInterfaceParent {
	after attribute replaced at caex::InterfaceClass[refBaseClassPath]
	call {
		logger.debug("ChangeInterfaceParent")
		
		if(AMLBasicStrings.automationMLBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.automationMLExternalBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalColladaBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalPLCopenBaseInterfaceName.equals(affectedEObject.name)
		) 
		{
			//TODO Änderung zurückrollen
			affectedEObject.refBaseClassPath = oldValue
			return
		}
		
		val root = EcoreUtil2.getContainerOfType(affectedEObject, CAEXFile)
		changeExternalInterfacesDueToNewParent(affectedEObject, root)
	}
}

reaction ChangeInterfaceName {
	after attribute replaced at caex::InterfaceClass[name]
	call {
		logger.debug("ChangeInterfaceName")
		
		if(AMLBasicStrings.automationMLExternalBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalColladaBaseInterfaceName.equals(affectedEObject.name)
			|| AMLBasicStrings.externalPLCopenBaseInterfaceName.equals(affectedEObject.name)
		) 
		{
			//TODO Änderung zurückrollen
			affectedEObject.name = oldValue
			return
		}
		
		val ownPath = CAEXStringResolver.getCompletePath(affectedEObject)
		changeRefBaseClassPathOfExternalInterfaces(affectedEObject, ownPath)
		val interfaceClasses = EcoreUtil2.getAllContentsOfType(affectedEObject, InterfaceClass)
		
		for(InterfaceClass currClass : interfaceClasses) {
			val currPath = CAEXStringResolver.getCompletePath(currClass)
			changeRefBaseClassPathOfExternalInterfaces(currClass, currPath)
		}
	}
}

reaction ChangeInterfaceLibName {
	after attribute replaced at caex::InterfaceClassLib[name]
	call {
		logger.debug("ChangeInterfaceLibName")
		
		if(AMLBasicStrings.automationMLBaseInterfaceName.equals(affectedEObject.name)) {
			//TODO Änderung zurückrollen
			affectedEObject.name = oldValue
			return
		}
		
		val interfaceClasses = EcoreUtil2.getAllContentsOfType(affectedEObject, InterfaceClass)
		
		for(InterfaceClass currClass : interfaceClasses) {
			val currPath = CAEXStringResolver.getCompletePath(currClass)
			//val newPath = newValue + currPath.substring(oldValue.length)
			changeRefBaseClassPathOfExternalInterfaces(currClass, currPath)
		}
	}
}

// *****

routine changeRefBaseClassPathOfExternalInterfaces(caex::InterfaceClass interfaceClass, String newPath) {
	match {
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to interfaceClass tagged with AMLTags.CLASS_INTERFACE
	}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				currInterface.refBaseClassPath = newPath
			}
			if(newPath.isNullOrEmpty) {
				for(ExternalInterface currInterface : externalInterfaces) {
					removeCorrespondenceToCollada(currInterface)
					removeCorrespondenceToPLCopen(currInterface)
				}
			}
		}
	}
}

routine changeExternalInterfacesDueToNewParent(caex::InterfaceClass interfaceClass, caex::CAEXFile root) {
	match {
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to interfaceClass tagged with AMLTags.CLASS_INTERFACE
	}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				removeUriAndCorrespondence(currInterface)
				addUri(currInterface, root)
			}
		}
	}
}

routine removeUriAndCorrespondence(caex::ExternalInterface externalInterface) {
	action {
		execute {
			val pathAttribute = CAEXUtils.getAttributeInExternalInterface(externalInterface, "refUri")
			if(pathAttribute !== null){
				externalInterface.^attribute.remove(pathAttribute)
				removeCorrespondenceToCollada(externalInterface)
				removeCorrespondenceToPLCopen(externalInterface)
			}
		}
	}
}

routine removeCorrespondenceToCollada(caex::ExternalInterface externalInterface) {
	match{
		val scene = retrieve collada::SceneType corresponding to externalInterface tagged with AMLTags.INTERFACE_SCENE
	}
	action {
		remove correspondence between scene and externalInterface tagged with AMLTags.INTERFACE_SCENE
	}
}

routine removeCorrespondenceToPLCopen(caex::ExternalInterface externalInterface) {
	match{
		val pou = retrieve plcopen::PouType1 corresponding to externalInterface tagged with AMLTags.INTERFACE_POU
	}
	action {
		remove correspondence between pou and externalInterface tagged with AMLTags.INTERFACE_POU
	}
}

routine addUri(caex::ExternalInterface externalInterface, caex::CAEXFile root) {
	match {
		check {
			CAEXInheritanceResolver.isInstanceOfPLCopenInterface(externalInterface, root) || CAEXInheritanceResolver.isInstanceOfColladaInterface(externalInterface, root)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = ""
		}
		update externalInterface {
			externalInterface.^attribute.add(newAttribute)
		}
	}
}

//Interface Typ kann nicht wechseln: Collada bleibt Collada, PLC bleibt PLC, andere werden nicht Collada oder PLC
routine changeInheritanceInInterfaces(String oldParent, String newParent, caex::CAEXFile root) {
	action {
		execute {
			val allInterfaces = EcoreUtil2.getAllContentsOfType(root, InterfaceClass)
			for(InterfaceClass currInterface : allInterfaces) {
				if(oldParent.equals(currInterface.refBaseClassPath)) {
					currInterface.refBaseClassPath = newParent
				}
			}
		}
	}
}