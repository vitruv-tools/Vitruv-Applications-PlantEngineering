import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import caex.caex30.caex.ExternalInterface
import caex.caex30.caex.CAEXFile
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.clonechangestests.InternalElementChecker
import caex.caex30.caex.InternalElement
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.SystemUnitClassForInterfaceChecker.InterfaceType
import caex.caex30.caex.impl.CAEXFactoryImpl
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import caex.caex30.caex.SystemUnitClass

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexSystemUnitClassChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Klasse bzw. Klassenbib entfernen

reaction RemoveSystemUnitClass {
	after element removed from caex::SystemUnitClass[systemUnitClass]
	call {
		System.out.println("Reaction RemoveSystemUnitClass")
				
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle internen Elemente, die diese oder eine untergeordnete Klasse referenzieren, gelöscht werden?").startInteraction
		if(userInput) {
			removeClones(oldValue)
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removeClones(currClass)
			}
		} else {
			removePrototypeFromInternalElement(oldValue)
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removePrototypeFromInternalElement(currClass)
			}
		}
	}
}

reaction RemoveSystemUnitClassFromBib {
	after element removed from caex::SystemUnitClassLib[systemUnitClass]
	call {
		System.out.println("Reaction RemoveSystemUnitClassFromBib")
				
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle internen Elemente, die diese oder eine untergeordnete Klasse referenzieren, gelöscht werden?").startInteraction
		if(userInput) {
			removeClones(oldValue)
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removeClones(currClass)
			}
		} else {
			removePrototypeFromInternalElement(oldValue)
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removePrototypeFromInternalElement(currClass)
			}
		}
	}
}

reaction RemoveSystemUnitClassLib {
	after element removed from caex::CAEXFile[systemUnitClassLib]
	call {
		System.out.println("Reaction RemoveSystemUnitClassLib")
				
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle internen Elemente, die Klassen dieser Bibliothek referenzieren, gelöscht werden?").startInteraction
		if(userInput) {
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removeClones(currClass)
			}
		} else {
			for(SystemUnitClass currClass : EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)) {
				removePrototypeFromInternalElement(currClass)
			}
		}
	}
}

// ***** ExternalInterface in Klassendefinition hinzufügen, entfernen

reaction AddExternalInterfaceToSystemClass {
	after element caex::ExternalInterface inserted in caex::SystemUnitClass[externalInterface]
	call {
		System.out.println("Reaction RemoveSystemUnitClassLib")
				
		val userInput = userInteractor.confirmationDialogBuilder.message("Soll in allen internen Elementen, die diese Klasse referenzieren, das Interface hinzugefügt werden?").startInteraction
		if(userInput) {
			addExternalInterfaceToInternalElement(newValue, affectedEObject)
		}		
	} 
}

reaction RemoveExternalInterfaceFromSystemClass {
	after element removed from caex::SystemUnitClass[externalInterface]
	with {
		oldValue instanceof ExternalInterface
	}
	call {
		System.out.println("Reaction RemoveExternalInterfaceFromSystemClass")
				
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		val externalInterfaceType = CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath, caexFile)
		val plcopenInterfacePath = "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface"
		val colladaInterfacePath = "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/COLLADAInterface"
		
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterfaceType, plcopenInterfacePath)) {
			removeCorrespondenceBetweenInterfaceInClassAndPLCopen(oldValue as ExternalInterface)
		} else if(CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterfaceType, colladaInterfacePath)) {
			removeCorrespondenceBetweenInterfaceInClassAndCollada(oldValue as ExternalInterface)
		}
		
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen in allen internen Elementen, die diese Klasse referenzieren, Interfaces entfernt werden?").startInteraction
		if(userInput) {
			removeExternalInterfaceFromInternalElement(oldValue as ExternalInterface, affectedEObject)
		}
	}
}

// ***** Routinen, um Klone beim Entfernen der Prototypen abzuändern bzw. zu löschen

routine removePrototypeFromInternalElement (caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass
	}
	action {
		execute {
			for(InternalElement currInternalElement : internalElements) {
				currInternalElement.refBaseSystemUnitPath = ""
			}
		}
	}
}

routine removeClones(caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass
	}
	action {
		execute {
			for(InternalElement currElem : internalElements) {
				removeClone(currElem)
			}
		}
	}
}

routine removeClone(caex::InternalElement internalElement) {
	action {
		delete internalElement
	}
}

// ***** Routinen, um interne Elemente abzuändern, analog zur Änderung der Klasse

routine addExternalInterfaceToInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass
		check {
			if(CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterface, "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
				return SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, InterfaceType.PLCOPEN)
			} else if(CAEXInheritanceResolver.isInterfaceInstanceOf(externalInterface, "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/COLLADAInterface")) {
				return SystemUnitClassForInterfaceChecker.checkForExternalInterface(systemUnitClass, InterfaceType.COLLADA)
			} else {
				return false
			}
		}
	}
	action {
		execute {
			val filteredList = InternalElementChecker.filterInternalElementsForChanges(internalElements, systemUnitClass)
			val caexFactory = new CAEXFactoryImpl()
			for(InternalElement currInternalElement : filteredList) {
				val newAttribute = caexFactory.createAttribute
				newAttribute.name = "refUri"
				newAttribute.attributeDataType = "xs:anyURI"
				newAttribute.value = InterfaceForAttributeChecker.getAttributeInExternalInterface(externalInterface, "refUri").value
				
				val newInterface = caexFactory.createExternalInterface
				newInterface.name = externalInterface.name
				newInterface.^attribute.add(newAttribute)
				newInterface.refBaseClassPath = externalInterface.refBaseClassPath
				currInternalElement.externalInterface.add(newInterface)
			}
		}
	}
}

routine removeExternalInterfaceFromInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass){
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to systemUnitClass 
	} action {
		execute {
			val filteredList = InternalElementChecker.filterInternalElementsForChanges(internalElements, systemUnitClass)
			for(InternalElement currInternalElement : filteredList) {
				val foundedInterface = SystemUnitClassForInterfaceChecker.getExternalInterface(currInternalElement, externalInterface.name)
				if(foundedInterface !== null) {
					currInternalElement.externalInterface.remove(foundedInterface)
				}
			}
		}
	}
}

// ***** Routinen, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung bzw. Geometrie zu entfernen

routine removeCorrespondenceBetweenInterfaceInClassAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface
	}
	action {
		remove correspondence between externalInterface and plcPouType
	}
}

routine removeCorrespondenceBetweenInterfaceInClassAndCollada (caex::ExternalInterface externalInterface){
	match {
		val colladaScene = retrieve collada::SceneType corresponding to externalInterface
	}
	action {
		remove correspondence between externalInterface and colladaScene
	}
}