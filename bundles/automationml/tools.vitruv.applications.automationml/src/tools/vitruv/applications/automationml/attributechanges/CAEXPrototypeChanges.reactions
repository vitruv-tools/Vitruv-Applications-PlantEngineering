import org.eclipse.xtext.EcoreUtil2
import java.util.LinkedList
import tools.vitruv.applications.automationml.utils.propertybasedtags.PrototypTags
import caex.caex30.caex.SystemUnitClassLib
import tools.vitruv.applications.automationml.utils.propertybasedtags.PropertyTags

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexAttributePrototypChanges
in reaction to changes in CAEX
execute actions in CAEX

// ***** Regel 1

reaction PrototypInsertedInLibrary {
	after element caex::SystemUnitClass inserted in caex::SystemUnitClassLib[systemUnitClass]
	call {
		val choices = new LinkedList<String>
		choices.add("always")
		choices.add("never")
		choices.add("depends on situation")
		val userInput = userInteractor.singleSelectionDialogBuilder.message("Sollen Klone dieses Prototypen immer angepasst werden?").choices(choices).startInteraction
		
		if (userInput == 0) {
			addTagBetweenClassAndLib(newValue, affectedEObject, PrototypTags.ALWAYS)
		} else if (userInput == 1) {
			addTagBetweenClassAndLib(newValue, affectedEObject, PrototypTags.NEVER)
		}
	}
}

reaction PrototypInsertedInClass {
	after element caex::SystemUnitClass inserted in caex::SystemUnitClass[systemUnitClass]
	call {
		val lib = EcoreUtil2.getContainerOfType(newValue, SystemUnitClassLib)
		
		val choices = new LinkedList<String>
		choices.add("always")
		choices.add("never")
		choices.add("depends on situation")
		val userInput = userInteractor.singleSelectionDialogBuilder.message("Sollen Klone dieses Prototypen immer angepasst werden?").choices(choices).startInteraction
		
		if (userInput == 0) {
			addTagBetweenClassAndLib(newValue, lib, PrototypTags.ALWAYS)
		} else if (userInput == 1) {
			addTagBetweenClassAndLib(newValue, lib, PrototypTags.NEVER)
		}
	}
}

// ***** Regel 2

reaction AttributeInsertedInClass {
	after element caex::Attribute inserted in caex::SystemUnitClass[^attribute]
	call {
		createTagsForProperties(affectedEObject, newValue)
	}
}

// ***** Methode zu Regel 2

routine createTagsForProperties (caex::SystemUnitClass prototype, caex::Attribute property) {
	match {
		val alwaysTaggedLib = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.ALWAYS
		val neverTaggedLib = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.NEVER
	}
	action {
		execute {
			if(!alwaysTaggedLib.isPresent && !neverTaggedLib.isPresent) {
				val choices = new LinkedList<String>
				choices.add("bahaviour, software security")
				choices.add("safty")
				choices.add("composition, geometrie, position")
				choices.add("material")
				choices.add("technical description")
				choices.add("norm, law")
				val userInput = userInteractor.singleSelectionDialogBuilder.message("Von welchem Typ ist diese Eigenschaft?").choices(choices).startInteraction
				
				switch(userInput) {
					case 0:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.BEHAVIOUR)
					case 1:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.SAFTY)
					case 2:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.COMPOSITION)
					case 3:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.MATERIAL)
					case 4:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.TECHNOLOGY)
					case 5:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.RULE)
				}
			}
		}
	}
} 

// ***** Allgemeine Methoden

routine addTagBetweenClassAndLib (caex::SystemUnitClass prototype, caex::SystemUnitClassLib lib, String tag) {
	action {
		add correspondence between prototype and lib tagged with tag
	}
}

routine addTagBetweenAttributeAndClass (caex::Attribute property, caex::SystemUnitClass prototype, String tag) {
	action {
		add correspondence between prototype and property tagged with tag
	}
}