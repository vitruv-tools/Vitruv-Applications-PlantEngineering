import org.eclipse.xtext.EcoreUtil2
import java.util.LinkedList
import tools.vitruv.applications.automationml.utils.propertybasedtags.PrototypTags
import caex.caex30.caex.SystemUnitClassLib
import tools.vitruv.applications.automationml.utils.propertybasedtags.PropertyTags
import tools.vitruv.applications.automationml.utils.aml.AMLTags
import caex.caex30.caex.InternalElement
import tools.vitruv.applications.automationml.utils.propertybasedtags.CloneTags
import caex.caex30.caex.SystemUnitClass

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexAttributePrototypChanges
in reaction to changes in CAEX
execute actions in CAEX

reaction PrototypeRemovedInLibrary {
	after element caex::SystemUnitClass removed from caex::SystemUnitClassLib[systemUnitClass]
	call {
		removeClones(oldValue)
		val prototypes = EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)
		for(SystemUnitClass currPrototype: prototypes) {
			removeClones(currPrototype)
		}
	}
}

reaction PrototypeRemovedInClass {
	after element caex::SystemUnitClass removed from caex::SystemUnitClass[systemUnitClass]
	call {
		removeClones(oldValue)
		val prototypes = EcoreUtil2.getAllContentsOfType(oldValue, SystemUnitClass)
		for(SystemUnitClass currPrototype: prototypes) {
			removeClones(currPrototype)
		}
	}
}

// ***** Regel 1

reaction PrototypInsertedInLibrary {
	after element caex::SystemUnitClass inserted in caex::SystemUnitClassLib[systemUnitClass]
	call {
		val choices = new LinkedList<String>
		choices.add("always")
		choices.add("never")
		choices.add("depends on situation")
		val userInput = userInteractor.singleSelectionDialogBuilder.message("Sollen Klone dieses Prototypen immer angepasst werden?").choices(choices).startInteraction
		
		if (userInput == 0) {
			addTagBetweenClassAndLib(newValue, affectedEObject, PrototypTags.ALWAYS)
		} else if (userInput == 1) {
			addTagBetweenClassAndLib(newValue, affectedEObject, PrototypTags.NEVER)
		}
	}
}

reaction PrototypInsertedInClass {
	after element caex::SystemUnitClass inserted in caex::SystemUnitClass[systemUnitClass]
	call {
		val lib = EcoreUtil2.getContainerOfType(newValue, SystemUnitClassLib)
		
		val choices = new LinkedList<String>
		choices.add("always")
		choices.add("never")
		choices.add("depends on situation")
		val userInput = userInteractor.singleSelectionDialogBuilder.message("Sollen Klone dieses Prototypen immer angepasst werden?").choices(choices).startInteraction
		
		if (userInput == 0) {
			addTagBetweenClassAndLib(newValue, lib, PrototypTags.ALWAYS)
		} else if (userInput == 1) {
			addTagBetweenClassAndLib(newValue, lib, PrototypTags.NEVER)
		}
	}
}

// ***** Regel 2

reaction AttributeInsertedInClass {
	after element caex::Attribute inserted in caex::SystemUnitClass[^attribute]
	call {
		createTagsForProperties(affectedEObject, newValue)
	}
}

// ***** Methode zu Regel 2

routine createTagsForProperties (caex::SystemUnitClass prototype, caex::Attribute property) {
	match {
		val alwaysTaggedLib = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.ALWAYS
		val neverTaggedLib = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.NEVER
		val clones = retrieve many caex::InternalElement corresponding to prototype tagged with AMLTags.PROTOTYPE_CLONE
	}
	action {
		execute {
			if(!alwaysTaggedLib.isPresent && !neverTaggedLib.isPresent) {
				val choices = new LinkedList<String>
				choices.add("bahaviour, software security")
				choices.add("safty")
				choices.add("composition, geometrie, position")
				choices.add("material")
				choices.add("technical description")
				choices.add("norm, law")
				val userInput = userInteractor.singleSelectionDialogBuilder.message("Von welchem Typ ist diese Eigenschaft?").choices(choices).startInteraction
				
				switch(userInput) {
					case 0:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.BEHAVIOUR)
					case 1:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.SAFTY)
					case 2:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.COMPOSITION)
					case 3:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.MATERIAL)
					case 4:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.TECHNOLOGY)
					case 5:
						addTagBetweenAttributeAndClass(property, prototype, PropertyTags.RULE)
				}
				
				for(InternalElement currClone : clones) {
					askUserToCopyNewProperty(property, currClone)
				}
			}
		}
	}
} 

routine askUserToCopyNewProperty (caex::Attribute property, caex::InternalElement clone) {
	match {
		val prototype = retrieve optional caex::SystemUnitClass corresponding to clone tagged with CloneTags.DESCRIPTIVE
	}
	action {
		execute {
			if(prototype.isPresent) {
				copyProperty(property, clone)
			} else {
				val userinput = userInteractor.confirmationDialogBuilder.message("Soll die Eigenschaft auf den Klon übertragen werden?").startInteraction
				if(userinput) {
					copyProperty(property, clone)
				}
			}
		}
	}
}

routine copyProperty (caex::Attribute property, caex::InternalElement clone) {
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = property.name
			newAttribute.value = property.value
		}
		update clone {
			clone.^attribute.add(newAttribute)
		}
	}
}

// bla

routine removeClones (caex::SystemUnitClass prototype) {
	match {
		val lib = retrieve optional caex::SystemUnitClassLib corresponding to prototype tagged with PrototypTags.NEVER
		val clones = retrieve many caex::InternalElement corresponding to prototype tagged with AMLTags.PROTOTYPE_CLONE
	}
	action {
		execute {
			if(!lib.isPresent) {
				for(InternalElement currClone : clones) {
					askUserToRemoveClone(currClone)
				}
			} else {
				for(InternalElement currClone : clones) {
					updateReference(currClone)
				}
			}
		}
	}
}

routine askUserToRemoveClone (caex::InternalElement clone) {
	match {
		val prototype = retrieve optional caex::SystemUnitClass corresponding to clone tagged with CloneTags.REAL
	}
	action {
		execute {
			if(!prototype.isPresent) {
				val userinput = userInteractor.confirmationDialogBuilder.message("Soll der aktuelle Klon gelöscht werden?").startInteraction
				if(userinput) {
					removeClone(clone)
				} else {
					updateReference(clone)
				}
			}
		}
	}
}

routine removeClone(caex::InternalElement clone) {
	action {
		delete clone
	}
}

routine updateReference(caex::InternalElement clone) {
	action {
		update clone {
			clone.refBaseSystemUnitPath = ""
		}
	}
}

// ***** Allgemeine Methoden

routine addTagBetweenClassAndLib (caex::SystemUnitClass prototype, caex::SystemUnitClassLib lib, String tag) {
	action {
		add correspondence between prototype and lib tagged with tag
	}
}

routine addTagBetweenAttributeAndClass (caex::Attribute property, caex::SystemUnitClass prototype, String tag) {
	action {
		add correspondence between prototype and property tagged with tag
	}
}