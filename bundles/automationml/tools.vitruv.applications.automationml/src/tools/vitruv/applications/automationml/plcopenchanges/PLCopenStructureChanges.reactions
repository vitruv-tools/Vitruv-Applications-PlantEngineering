import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import org.plcopen.xml.tc60201.PouType1
import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.amlutils.TagHelper

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: plcopenStructureChanges
in reaction to changes in PLCOpen
execute actions in PLCOpen

// ***** Root anlegen/löschen

reaction CreatePLCopenRoot {
	after element plcopen::ProjectType created
	call {
		logger.debug("CreatePLCopenRoot")
		
		createPLCopenContainer(affectedEObject)
		createPLCopenStructure(affectedEObject)
	}
}

reaction RemovePLCopenRoot {
	after element plcopen::ProjectType deleted
	call {
		logger.debug("RemovePLCopenRoot")
		
		val pouType = EcoreUtil2.getAllContentsOfType(affectedEObject, PouType1).get(0) 
		
		changePathForPLCopenInterfacesToEmpty(pouType)
		removePLCopenContainer(affectedEObject)
	}
}

// ***** zusätzliche Beschreibungcontainer anlegen/löschen

reaction CreatePouType {
	after element plcopen::PouType1 created
	call {
		logger.debug("CreatePouType")
		
		//TODO Methode entspricht einem Zurückrollen der Änderung
		deletePouType(affectedEObject)
	}
}

reaction DeletePouType {
	after element plcopen::PouType1 removed from plcopen::PousType[pou]
	call {
		logger.debug("DeletePouType")
		
		//TODO Änderung zurückrollen
		// kein Sprachstatement vorhanden, deswegen diese Formulierung
		affectedEObject.pou.add(oldValue)
	}
}

reaction DeletePousType {
	after element plcopen::PousType removed from plcopen::TypesType[pous]
	call {
		logger.debug("DeletePousType")
		
		//TODO Methode entspricht einem Zurückrollen der Änderung
		recreatePousType(affectedEObject, oldValue)
	}
}

reaction DeleteTypesType {
	after element plcopen::TypesType removed from plcopen::ProjectType[types]
	call {
		logger.debug("DeleteTypesType")
		
		//TODO Methode entspricht einem Zurückrollen der Änderung
		recreateTypesType(affectedEObject, oldValue)
	}
}

// ***** Routinen, um Container für PLCopen anzulegen oder zu entfernen

routine createPLCopenContainer(plcopen::ProjectType projectType) {
	action {
		val container = create aml::PLCopenContainer and initialize {
			container.path = ""
		} 
		add correspondence between projectType and container tagged with TagHelper.TAG
	}
}

routine removePLCopenContainer(plcopen::ProjectType projectType) {
	match {
		val container = retrieve aml::PLCopenContainer corresponding to projectType tagged with TagHelper.TAG
	}
	action {
		delete container
	}
}

// Routine, um Interfaces an gelöschte Dateien anzupassen

routine changePathForPLCopenInterfacesToEmpty(plcopen::PouType1 pouType) {
	match {
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to pouType tagged with TagHelper.TAG
	}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				val pathAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(currInterface, "refUri")
				pathAttribute.value = ""
			}
		}
	}
}

// ***** Routine, um Grundstruktur der Datei anzulegen

routine createPLCopenStructure(plcopen::ProjectType projectType) {
	action {
		val pouType = create plcopen::PouType1
		val pousType = create plcopen::PousType and initialize {
			pousType.pou.add(pouType)
		}
		val typesType = create plcopen::TypesType and initialize {
			typesType.pous = pousType
		}
		update projectType {
			projectType.types = typesType
		}
	}
}

// ***** Routinen, um Grundstruktur der Datei beizubehalten

routine deletePouType(plcopen::PouType1 pouType) {
	action {
		delete pouType
	}
}

routine recreatePousType(plcopen::TypesType typesType, plcopen::PousType pousType) {
	match {
		check {
			pousType.pou.size == 1
		}
	}
	action {
		update typesType {
			typesType.pous = pousType
		}
	}
}

routine recreateTypesType(plcopen::ProjectType projectType, plcopen::TypesType typesType) {
	match {
		check {
			typesType.pous.pou.size == 1
		}
	}
	action {
		update projectType {
			projectType.types = typesType
		}
	}
}