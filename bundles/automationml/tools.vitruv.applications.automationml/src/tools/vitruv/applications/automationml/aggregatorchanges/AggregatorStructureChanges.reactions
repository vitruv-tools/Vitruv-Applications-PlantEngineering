import org.eclipse.xtext.EcoreUtil2
import org.plcopen.xml.tc60201.PouType1
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import org.khronos.collada.SceneType
import edu.kit.sdq.aml_aggregator.ColladaContainer
import edu.kit.sdq.aml_aggregator.PLCopenContainer
import tools.vitruv.applications.automationml.utils.amlutils.TagHelper
import tools.vitruv.applications.automationml.utils.amlutils.ResourcesHelper

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: aggregatorStructureChanges
in reaction to changes in AML
execute actions in AML

// ***** AML Projekt anlegen/ entfernen

// Reaction notwendig??
reaction CreateAMLProject {
	after element aml::AMLProject created and inserted as root
	call {
		logger.debug("Reaction CreateAMLProject")
		
		createCAEXContainerAndFile()
	}
}

reaction RemoveAMLProject {
	after element aml::AMLProject removed as root
	call {
		logger.debug("Reaction RemoveAMLProject")
		
		val userInput = userInteractor.confirmationDialogBuilder.message("Das ganze Projekt würde gelöscht werden. Fortfahren?").startInteraction
		if(userInput) {
			deleteCAEXFile(oldValue.caexcontainer)
			for(ColladaContainer currContainer : oldValue.colladacontainer) {
				deleteColladaFile(currContainer)
			}
			for(PLCopenContainer currContainer : oldValue.plcopencontainer) {
				deletePLCopenFile(currContainer)
			}
		} else {
			//TODO Änderung zurückrollen
			// kein Sprachstatement vorhanden, deswegen diese Formulierung
			oldValue.eResource.contents.add(oldValue)
		}
	}
}

// ***** CAEX erzeugen/löschen

reaction ReplaceCAEXContainer {
	after element aml::CAEXContainer replaced at aml::AMLProject[caexcontainer]
	call {
		logger.debug("Reaction ReplaceCAEXContainer")
		
		if(newValue === null) {
			//TODO Änderung zurückrollen
			// kein Sprachstatement vorhanden, deswegen diese Formulierung
			affectedEObject.caexcontainer = oldValue
			return;
		}
		
		deleteCAEXFile(oldValue)
		createCAEXFile(newValue)
	}
}

// ***** Collada oder PLCopen Datei anlegen/löschen

reaction CreateColladaContainer {
	after element aml::ColladaContainer created
	call {
		logger.debug("Reaction CreateColladaContainer")
		
		affectedEObject.path = ""
		createColladaFile(affectedEObject)
	}
}

reaction CreatePLCopenContainer {
	after element aml::PLCopenContainer created
	call {
		logger.debug("Reaction CreatePLCopenContainer")
		
		affectedEObject.path = ""
		createPLCopenFile(affectedEObject)
	}
}

reaction RemoveColladaContainer {
	after element aml::ColladaContainer deleted
	call {
		logger.debug("Reaction RemoveColladaContainer")
		
		deleteColladaFile(affectedEObject)
	}
}

reaction RemovePLCopenContainer {
	after element aml::PLCopenContainer deleted
	call {
		logger.debug("Reaction RemovePLCopenContainer")
		
		deletePLCopenFile(affectedEObject)
	}
}

// ***** Routine, um ein komplettes Projekt zu löschen

routine removeAMLProject(aml::AMLProject amlProject){
	action {
		delete amlProject
	}
}

// ***** Routinen, um Dateien zu erzeugen

routine createCAEXContainerAndFile() {
	action {
		val container = create aml::CAEXContainer and initialize {
			container.path = ""
		}
		execute {
			createCAEXFile(container)
		}
	}
}

routine createCAEXFile(aml::CAEXContainer container) {
	action {
		val caexFile = create caex::CAEXFile
		add correspondence between container and caexFile tagged with TagHelper.TAG
		execute {
			val caexNumber = ResourcesHelper.newNumberOfCAEXFiles
			persistProjectRelative(container, caexFile, "resources/resources-gen/caex" + caexNumber + ".caex")
		}
	}
}

routine createPLCopenFile(aml::PLCopenContainer container) {
	action {
		val pouType = create plcopen::PouType1
		val pousType = create plcopen::PousType and initialize {
			pousType.pou.add(pouType)
		}
		val typesType = create plcopen::TypesType and initialize {
			typesType.pous = pousType
		}
		val projectType = create plcopen::ProjectType and initialize {
			projectType.types = typesType
		}
		add correspondence between projectType and container tagged with TagHelper.TAG
		execute { 
			val plcNumber = ResourcesHelper.newNumberOfPLCopenFiles
			persistProjectRelative(container, projectType, "resources/resources-gen/plc" + plcNumber + ".tc60201")
		}
	}
}

routine createColladaFile(aml::ColladaContainer container) {
	action {
		//TODO alles weitere erzeugen
		val colladaType = create collada::COLLADAType and initialize {
			
		}
		add correspondence between colladaType and container tagged with TagHelper.TAG
		execute {
			val colladaNumber = ResourcesHelper.newNumberOfColladaFiles
			persistProjectRelative(container, colladaType, "resources/resources-gen/collada" + colladaNumber + ".dae")
		}
	}
}

// ***** Routinen, um Dateien zu löschen

routine deleteCAEXFile(aml::CAEXContainer container) {
	match {
		val caexFile = retrieve caex::CAEXFile corresponding to container tagged with TagHelper.TAG
	}
	action {
		delete caexFile
	}
}

routine deletePLCopenFile(aml::PLCopenContainer container) {
	match {
		val plcProject = retrieve plcopen::ProjectType corresponding to container tagged with TagHelper.TAG
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to EcoreUtil2.getAllContentsOfType(plcProject, PouType1).get(0) tagged with TagHelper.TAG
	}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				changePathForInterfaceToEmpty(currInterface)
			}
		}
		delete plcProject
	}
}

routine deleteColladaFile(aml::ColladaContainer container) {
	match {
		val colladaType = retrieve collada::COLLADAType corresponding to container tagged with TagHelper.TAG
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to EcoreUtil2.getAllContentsOfType(colladaType, SceneType).get(0) tagged with TagHelper.TAG
		}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				changePathForInterfaceToEmpty(currInterface)
			}
		}
		delete colladaType
	}
}

routine changePathForInterfaceToEmpty(caex::ExternalInterface externalInterface) {
	action {
		execute {
			val pathAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(externalInterface, "refUri")
			pathAttribute.value = ""
		}
	}
}
