import org.eclipse.xtext.EcoreUtil2
import org.plcopen.xml.tc60201.PouType1
import caex.caex30.caex.ExternalInterface
import tools.vitruv.applications.automationml.utils.externalInterfaceUtils.InterfaceForAttributeChecker
import org.khronos.collada.SceneType
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.common.util.URI
import edu.kit.sdq.aml_aggregator.ColladaContainer
import edu.kit.sdq.aml_aggregator.PLCopenContainer

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: aggregatorStructureChanges
in reaction to changes in AML
execute actions in AML

// ***** AML Projekt anlegen/ entfernen

reaction CreateAMLProject {
	after element aml::AMLProject created and inserted as root
	call {
		System.out.println("Reaction CreateAMLProject")
		
		createCAEXContainerAndFile()
	}
}

reaction RemoveAMLProject {
	after element aml::AMLProject removed as root
	call {
		System.out.println("Reaction RemoveAMLProject")
		
		val userInput = userInteractor.confirmationDialogBuilder.message("Das ganze Projekt würde gelöscht werden. Fortfahren?").startInteraction
		if(userInput) {
			deleteCAEXFile(oldValue.caexcontainer)
			for(ColladaContainer currContainer : oldValue.colladacontainer) {
				deleteColladaFile(currContainer)
			}
			for(PLCopenContainer currContainer : oldValue.plcopencontainer) {
				deletePLCopenFile(currContainer)
			}
		} else {
			// Änderung zurückrollen
			// kein Sprachstatement vorhanden, deswegen diese Formulierung
			oldValue.eResource.contents.add(oldValue)
		}
	}
}

// ***** CAEX Datei löschen

reaction RemoveCAEXContainer {
	after element aml::CAEXContainer removed from aml::AMLProject[caexcontainer]
	call {
		System.out.println("Reaction RemoveCAEXContainer")
		
		val userInput = userInteractor.confirmationDialogBuilder.message("AML-Projekt kann ohne CAEX-Datei nicht existieren. Fortfahren? Dabei würde das ganze Projekt gelöscht werden.").startInteraction
		if(userInput) {
			deleteCAEXFile(oldValue)
			for(ColladaContainer currContainer : affectedEObject.colladacontainer) {
				deleteColladaFile(currContainer)
			}
			for(PLCopenContainer currContainer : affectedEObject.plcopencontainer) {
				deletePLCopenFile(currContainer)
			}
			removeAMLProject(affectedEObject)
		} else {
			// Änderung zurückrollen
			// kein Sprachstatement vorhanden, deswegen diese Formulierung
			affectedEObject.caexcontainer = oldValue
		}
	}
}

// ***** Collada oder PLCopen Datei anlegen/löschen

reaction CreateColladaContainer {
	after element aml::ColladaContainer created
	call {
		System.out.println("Reaction CreateColladaContainer")
		
		affectedEObject.path = ""
		createColladaFile(affectedEObject)
	}
}

reaction CreatePLCopenContainer {
	after element aml::PLCopenContainer created
	call {
		System.out.println("Reaction CreatePLCopenContainer")
		
		affectedEObject.path = ""
		createPLCopenFile(affectedEObject)
	}
}

reaction RemoveColladaContainer {
	after element aml::ColladaContainer deleted
	call {
		System.out.println("Reaction RemoveColladaContainer")
		
		deleteColladaFile(affectedEObject)
	}
}

reaction RemovePLCopenContainer {
	after element aml::PLCopenContainer deleted
	call {
		System.out.println("Reaction RemovePLCopenContainer")
		
		deletePLCopenFile(affectedEObject)
	}
}

// ***** Routine, um ein komplettes Projekt zu löschen

routine removeAMLProject(aml::AMLProject amlProject){
	action {
		delete amlProject
	}
}

// ***** Routinen, um Dateien zu erzeugen

routine createCAEXContainerAndFile() {
	action {
		val container = create aml::CAEXContainer and initialize {
			container.path = ""
		}
		val caexFile = create caex::CAEXFile
		add correspondence between container and caexFile
		execute {
			val rs = new ResourceSetImpl()
			val uri = URI.createURI("")		//TODO Pfad
			val res = rs.createResource(uri)
			res.contents.add(caexFile)
			//res.save()
		}
	}
}

routine createPLCopenFile(aml::PLCopenContainer container) {
	action {
		val pouType = create plcopen::PouType1
		val pousType = create plcopen::PousType and initialize {
			pousType.pou.add(pouType)
		}
		val typesType = create plcopen::TypesType and initialize {
			typesType.pous = pousType
		}
		val projectType = create plcopen::ProjectType and initialize {
			projectType.types = typesType
		}
		add correspondence between projectType and container
		execute {
			val rs = new ResourceSetImpl()
			val uri = URI.createURI("")		//TODO Pfad
			val res = rs.createResource(uri)
			res.contents.add(projectType)
			//res.save()
		}
	}
}

routine createColladaFile(aml::ColladaContainer container) {
	action {
		//TODO alles weitere erzeugen
		val colladaType = create collada::COLLADAType and initialize {
			
		}
		add correspondence between colladaType and container
		execute {
			val rs = new ResourceSetImpl()
			val uri = URI.createURI("")		//TODO Pfad
			val res = rs.createResource(uri)
			res.contents.add(colladaType)
			//res.save()
		}
	}
}

// ***** Routinen, um Dateien zu löschen

routine deleteCAEXFile(aml::CAEXContainer container) {
	match {
		val caexFile = retrieve caex::CAEXFile corresponding to container
	}
	action {
		delete caexFile
	}
}

routine deletePLCopenFile(aml::PLCopenContainer container) {
	match {
		val plcProject = retrieve plcopen::ProjectType corresponding to container
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to EcoreUtil2.getAllContentsOfType(plcProject, PouType1).get(0)
	}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				changePathForInterfaceToEmpty(currInterface)
			}
		}
		delete plcProject
	}
}

routine deleteColladaFile(aml::ColladaContainer container) {
	match {
		val colladaType = retrieve collada::COLLADAType corresponding to container
		val externalInterfaces = retrieve many caex::ExternalInterface corresponding to EcoreUtil2.getAllContentsOfType(colladaType, SceneType).get(0)
		}
	action {
		execute {
			for(ExternalInterface currInterface : externalInterfaces) {
				changePathForInterfaceToEmpty(currInterface)
			}
		}
		delete colladaType
	}
}

routine changePathForInterfaceToEmpty(caex::ExternalInterface externalInterface) {
	action {
		execute {
			val pathAttribute = InterfaceForAttributeChecker.getAttributeInExternalInterface(externalInterface, "refUri")
			pathAttribute.value = ""
		}
	}
}
