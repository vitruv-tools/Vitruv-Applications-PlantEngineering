import org.eclipse.xtext.EcoreUtil2
import tools.vitruv.applications.automationml.utils.aml.AMLTags
import tools.vitruv.applications.automationml.utils.aml.AMLBasicStrings
import caex.caex30.caex.RoleClass
import caex.caex30.caex.InternalElement
import tools.vitruv.applications.automationml.utils.stringreferences.caex.RoleClassUtils

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://www.dke.de/CAEX/300" as caex
import "http://edu.kit.ipd.sdq.aml" as aml
import "http://www.collada.org/2005/11/COLLADASchema" as collada

reactions: caexRoleLibraryChanges
in reaction to changes in CAEX
execute actions in CAEX

//Sometimes in this reactions, a change will be rejected. This happens due to the fact, that standard interfaces, which came along with AML, are not allowed to change

/**
 * reaction to remove a role class library
 */
reaction RemoveRoleClassLibrary {
	after element caex::RoleClassLib removed from caex::CAEXFile[roleClassLib]
	call {
		if(AMLBasicStrings.automationMLRoleClassLibName.equals(oldValue.name)) {
			//TODO reject change
			affectedEObject.roleClassLib += oldValue
			return
		}
		
		val listOfRoleClasses = EcoreUtil2.getAllContentsOfType(oldValue, RoleClass)
		for(RoleClass currClass : listOfRoleClasses) {
			changeRefBaseClassPathOfInternalElements(currClass, "")
		}
	}
}

/**
 * reaction to remove a role class
 */
reaction RemoveRoleClass {
	after element caex::RoleClass removed from caex::RoleClass[roleClass]
	call {
		if(AMLBasicStrings.automationMLBaseRoleName.equals(oldValue.name)) 
		{
			//TODO reject change
			affectedEObject.roleClass += oldValue
			return
		}
				
		changeRefBaseClassPathOfInternalElements(oldValue, "")
		
		val listOfRoleClasses = EcoreUtil2.getAllContentsOfType(oldValue, RoleClass)
		for(RoleClass currClass : listOfRoleClasses) {
			changeRefBaseClassPathOfInternalElements(currClass, "")
		}
	}
}

/**
 * reaction to remove a role class
 */
reaction RemoveRoleClassFromLib {
	after element caex::RoleClass removed from caex::RoleClassLib[roleClass]
	call {
		if(AMLBasicStrings.automationMLBaseRoleName.equals(oldValue.name)) {
			//TODO reject change
			affectedEObject.roleClass += oldValue
			return
		}
		
		changeRefBaseClassPathOfInternalElements(oldValue, "")
		
		val listOfRoleClasses = EcoreUtil2.getAllContentsOfType(oldValue, RoleClass)
		for(RoleClass currClass : listOfRoleClasses) {
			changeRefBaseClassPathOfInternalElements(currClass, "")
		}
	}
}

/**
 * reaction to change the name of a role class
 */
reaction ChangeRoleName {
	after attribute replaced at caex::RoleClass[name]
	call {		
		if(AMLBasicStrings.automationMLBaseRoleName.equals(oldValue)) 
		{
			//TODO reject change
			affectedEObject.name = oldValue
			return
		}
		
		val ownPath = RoleClassUtils.getCompletePathOfRoleClass(affectedEObject)
		changeRefBaseClassPathOfInternalElements(affectedEObject, ownPath)
		val roleClasses = EcoreUtil2.getAllContentsOfType(affectedEObject, RoleClass)
		
		for(RoleClass currClass : roleClasses) {
			val currPath = RoleClassUtils.getCompletePathOfRoleClass(currClass)
			changeRefBaseClassPathOfInternalElements(currClass, currPath)
		}
	}
}

/**
 * reaction to change the name of a role class library
 */
reaction ChangeRoleLibName {
	after attribute replaced at caex::RoleClassLib[name]
	call {		
		if(AMLBasicStrings.automationMLRoleClassLibName.equals(oldValue)) {
			//TODO reject change
			affectedEObject.name = oldValue
			return
		}
		
		val roleClasses = EcoreUtil2.getAllContentsOfType(affectedEObject, RoleClass)
		
		for(RoleClass currClass : roleClasses) {
			val currPath = RoleClassUtils.getCompletePathOfRoleClass(currClass)
			changeRefBaseClassPathOfInternalElements(currClass, currPath)
		}
	}
}

/**
 * routine to adapt the role description of an InternalElement, if the role was changed or removed
 */
routine changeRefBaseClassPathOfInternalElements(caex::RoleClass roleClass, String newPath) {
	match {
		val internalElements = retrieve many caex::InternalElement corresponding to roleClass tagged with AMLTags.CLONE_ROLE
	}
	action {
		execute {
			for(InternalElement currElem : internalElements) {
				currElem.refBaseClassPath = newPath
			}
		}
	}
}