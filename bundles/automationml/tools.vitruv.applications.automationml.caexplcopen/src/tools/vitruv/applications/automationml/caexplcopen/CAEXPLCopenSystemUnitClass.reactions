import org.automationml.caex.caex.CAEXFile
import org.eclipse.xtext.EcoreUtil2
import org.automationml.caex.caex.ExternalInterface
import org.automationml.caex.caex.InterfaceClass
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXInheritanceResolver
import tools.vitruv.applications.automationml.utils.caexresolver.CAEXStringResolver
import tools.vitruv.applications.automationml.utils.externalInterfaceIncluded.SystemUnitClassForInterfaceChecker
import tools.vitruv.applications.automationml.utils.clonechangestests.InternalElementChecker

import "http://www.plcopen.org/xml/tc6_0201" as plcopen
import "http://org.automationml.caex" as caex

reactions: caexplcopensystemunitclass
in reaction to changes in CAEX
execute actions in PLCOpen

// ***** Klasse bzw. Klassenbib entfernen

reaction RemoveSystemUnitClass {
	after element removed from caex::SystemUnitClass[systemUnitClass]
	call {
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle internen Elemente, die diese Klasse referenzieren, gelöscht werden?").startInteraction
		if(userInput) {
			removeClone(oldValue)
		} else {
			removePrototypeFromInternalElement(oldValue)
		}
	}
}

reaction RemoveSystemUnitClassFromBib {
	after element removed from caex::SystemUnitClassLib[systemUnitClass]
	call {
		val userInput = userInteractor.confirmationDialogBuilder.message("Sollen alle internen Elemente, die diese Klasse referenzieren, gelöscht werden?").startInteraction
		if(userInput) {
			removeClone(oldValue)
		} else {
			removePrototypeFromInternalElement(oldValue)
		}
	}
}

reaction RemoveSystemUnitClassLib {
	after element removed from caex::CAEXFile[systemUnitClassLib]
	call {
		// evtl gar nichts, kommt auf rekursion beim löschen an...
	}
}

// ***** ExternalInterface in Klassendefinition hinzufügen, entfernen

reaction AddExternalInterfaceToSystemClass {
	after element caex::ExternalInterface inserted in caex::SystemUnitClass[externalInterface]
	call {
		val userInput = userInteractor.confirmationDialogBuilder.message("Soll in allen internen Elementen, die diese Klasse referenzieren, Interfaces hinzugefügt werden?").startInteraction
		if(userInput) {
			addExternalInterfaceToInternalElement(newValue, affectedEObject)
		}		
	} 
}

reaction RemoveExternalInterfaceFromSystemClass {
	after element removed from caex::SystemUnitClass[externalInterface]
	with {
		oldValue instanceof ExternalInterface
	}
	call {
		val caexFile = EcoreUtil2.getContainerOfType(oldValue, CAEXFile)
		if(CAEXInheritanceResolver.isInterfaceInstanceOf(CAEXStringResolver.resolveInterfacePath(oldValue.refBaseClassPath ,caexFile), "AutomationMLInterfaceClassLib/AutomationMLBaseInterface/ExternalDataConnector/PLCopenXMLInterface")) {
			removeCorrespondenceBetweenInterfaceInClassAndPLCopen(oldValue as ExternalInterface)
		}
		
		val userInput = userInteractor.confirmationDialogBuilder.message("Soll in allen internen Elementen, die diese Klasse referenzieren, Interfaces entfernt werden?").startInteraction
		if(userInput) {
			removeExternalInterfaceFromInternalElement(oldValue as ExternalInterface, affectedEObject)
		}
	}
}

// ***** Routinen, um Klone beim Entfernen der Prototypen abzuändern bzw. zu löschen

routine removePrototypeFromInternalElement (caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElement = retrieve caex::InternalElement corresponding to systemUnitClass
	}
	action {
		update internalElement {
			internalElement.refBaseSystemUnitPath = ""
		}
		remove correspondence between internalElement and systemUnitClass
	}
}

routine removeClone(caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElement = retrieve caex::InternalElement corresponding to systemUnitClass
	}
	action {
		remove correspondence between internalElement and systemUnitClass
		delete internalElement
	}
}

// ***** Routinen, um interne Elemente abzuändern, analog zur Änderung der Klasse

routine addExternalInterfaceToInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass) {
	match {
		val internalElement = retrieve caex::InternalElement corresponding to systemUnitClass
		check {
			SystemUnitClassForInterfaceChecker.checkForExternalPLCInterface(systemUnitClass)
		}
		check {
			InternalElementChecker.checkInternalElementForChanges(internalElement, systemUnitClass)
		}
	}
	action {
		val newAttribute = create caex::Attribute and initialize {
			newAttribute.name = "refUri"
			newAttribute.attributeDataType = "xs:anyURI"
			newAttribute.value = SystemUnitClassForInterfaceChecker.getExternalPLCInterface(systemUnitClass).^attribute.get(0).value
		}
		val newInterface = create caex::ExternalInterface and initialize {
			newInterface.name = externalInterface.name
			newInterface.^attribute.add(newAttribute)
			newInterface.refBaseClassPath = externalInterface.refBaseClassPath
		}
		update internalElement {
			internalElement.externalInterface.add(newInterface)
		}
	}
}

routine removeExternalInterfaceFromInternalElement(caex::ExternalInterface externalInterface, caex::SystemUnitClass systemUnitClass){
	match {
		val internalElement = retrieve caex::InternalElement corresponding to systemUnitClass 
		check {
			InternalElementChecker.checkInternalElementForChanges(internalElement, systemUnitClass)
		}
	} action {
		update internalElement {
			for (InterfaceClass currExternalInterface : internalElement.externalInterface){
				if(currExternalInterface instanceof ExternalInterface) {
					if(currExternalInterface.name.equals(externalInterface.name)){
						// kann das klappen??
						internalElement.externalInterface.remove(currExternalInterface)
					}
				}
			}
		}
	}
}

// ***** Routine, um Korrespondenzen zwischen Interface und Verhaltensbeschreibung zu entfernen

routine removeCorrespondenceBetweenInterfaceInClassAndPLCopen (caex::ExternalInterface externalInterface){
	match {
		val plcPouType = retrieve plcopen::PouType1 corresponding to externalInterface
	}
	action {
		remove correspondence between externalInterface and plcPouType
	}
}

