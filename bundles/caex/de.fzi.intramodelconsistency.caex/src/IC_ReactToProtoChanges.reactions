import de.fzi.intramodelconsistency.caex.CAEXIntraConsistencyTools
import org.eclipse.emf.ecore.EStructuralFeature
import CAEX.CAEXFactory
import CAEX.InternalElement
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.EObject
import CAEX.CAEXObject
import org.eclipse.emf.common.util.BasicEList

import "http://org.automationml.caex" as CAEX

reactions: IC_ReactToProtoChanges
in reaction to changes in CAEX
execute actions in CAEX

/** On Prototype name change also adjust refBaseSystemUnitClassPath of all correspondents*/
reaction PrototypeNameChanged {
	after attribute replaced at CAEX::SystemUnitClass[name]
	call  {
		if((affectedEObject instanceof InternalElement)) return;
		correctPathsSystemUnitClassClones(affectedEObject)
	}
}

/** On Prototype changeMode change also adjust correspondents */
reaction PrototypeChangeModeChanged {
	after attribute replaced at CAEX::SystemUnitClass[changeMode]
	call {
		val feature = CAEXFactory.eINSTANCE.createInternalElement.eClass.getEStructuralFeature("changeMode")
		
		correctSystemUnitClassClones(affectedEObject, feature, newValue)
	}
}

/** On new attribute in Prototype, also add the same attribute to clones */
reaction PrototypeAttributeAdded {
	after element inserted in CAEX::SystemUnitClass[^attribute]
	call {
		val feature = CAEXFactory.eINSTANCE.createInternalElement.eClass.getEStructuralFeature("attribute")		
		correctSystemUnitClassClones(affectedEObject, feature, newValue)
	}
}

/** On new additionalInformation in Prototype, add same object to clones */
reaction PrototypeAdditionalInformationAdded {
	after element inserted in CAEX::SystemUnitClass[additionalInformation]
	call {
		val feature = CAEXFactory.eINSTANCE.createInternalElement.eClass.getEStructuralFeature("additionalInformation")		
		correctSystemUnitClassClones(affectedEObject, feature, newValue)
	}
}

/**
 * Routine that recursively corrects the references in refBaseClassPaths of a SystemUnitClass and all it's children SystemUnitClasses
 */
routine correctPathsSystemUnitClassClones(CAEX::SystemUnitClass affectedEObject) {
	action {
		call {
			//TODO: Modify to only start correction for Elements with correspondences 			
			val newRefBasePath = CAEXIntraConsistencyTools.generatePathFromTuid(correspondenceModel,affectedEObject,correspondenceModel.calculateTuidFromEObject(affectedEObject))		
			val feature = CAEXFactory.eINSTANCE.createInternalElement.eClass.getEStructuralFeature("refBaseSystemUnitPath")
			correctSystemUnitClassClones(affectedEObject, feature, newRefBasePath)
			
			//Recursively correct the paths of all children elements 
			if(!affectedEObject.systemUnitClass.empty)
				affectedEObject.systemUnitClass.forEach[correctPathsSystemUnitClassClones]
		}
	}
}

routine correctSystemUnitClassClones(CAEX::SystemUnitClass changedPrototype, plain EStructuralFeature as feature, plain Object as newValue){
	match {
		val clones = retrieve many CAEX::InternalElement corresponding to changedPrototype
		}
	action {	
		call {
			for(clon : clones){
				updateFeature(clon, feature, newValue)				
				clon.eResource.modified = true
				}
		}
	}
}

routine addCAEXCorrespondence(CAEX::CAEXObject a,CAEX::CAEXObject b){
	action{
		add correspondence between a and b
	}
}

routine updateFeature(EObject obj, plain EStructuralFeature as feature, plain Object as newValue){
	action {
		call {
			val featureValue = obj.eGet(feature)
			if (featureValue instanceof EList){
				val clone = EcoreUtil.copy(newValue as EObject)
				featureValue.add(clone);				
				obj.setFeatureValue(feature,new BasicEList(featureValue.clone))
				addCAEXCorrespondence(clone as CAEXObject ,newValue as CAEXObject)
			}				
			else{
				obj.setFeatureValue(feature, newValue)
			}	
		}
	}
}

routine setFeatureValue(EObject e, plain EStructuralFeature as f, plain Object as o) {
	action{
		update e {
			e.eSet(f,o)
			e.eResource.modified=true
		}
	}
}